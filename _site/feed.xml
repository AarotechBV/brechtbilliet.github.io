<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Frontend software architect living in Belgium</title>
    <description></description>
    <link>https://blog.brecht.io/</link>
    <atom:link href="https://blog.brecht.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 05 Jul 2022 21:43:19 +0200</pubDate>
    <lastBuildDate>Tue, 05 Jul 2022 21:43:19 +0200</lastBuildDate>
    <generator>Jekyll v4.2.2</generator>
    
      <item>
        <title>How covid affected StrongBrew</title>
        <description>&lt;h2 id=&quot;covid&quot;&gt;Covid&lt;/h2&gt;

&lt;p&gt;These are challenging times… Harsh times for people and companies. Even for some companies it results in fatal decisions.&lt;/p&gt;

&lt;p&gt;Unfortunately we were impacted by COVID as well, as we haven’t earned a single dime since March 2020.
If we take this painful aspect into consideration in combination with the fact that Kwinten is pursuing a new job at Stackblitz we decided to stop the legal entity StrongBrew VOF. StrongBrew VOF is no more… I (Brecht) personally want to thank Kwinten for this awesome adventure and I hope we can work together once again in the future.&lt;/p&gt;

&lt;p&gt;That being said… I will continue all StrongBrew activities except the trainings. The brews that we have given, both locally and internationally will not be updated anymore, nor will they be given in companies. We want to thank all of you for following our trainings, reading our content and trusting us with important problems.&lt;/p&gt;

&lt;h2 id=&quot;blog&quot;&gt;Blog&lt;/h2&gt;

&lt;p&gt;Most articles of the blog are more than a year old. My goal is to pump new life into the blog and help you all with technical content and personal experience. I still do Angular/RxJS/Architecture on a full time basis and recently started freelancing for a new awesome startup called &lt;a href=&quot;https://www.rosa.be/&quot;&gt;rosa&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The techstack we use there is:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Angular&lt;/li&gt;
  &lt;li&gt;Nx&lt;/li&gt;
  &lt;li&gt;Typescript&lt;/li&gt;
  &lt;li&gt;RxJS&lt;/li&gt;
  &lt;li&gt;Nest.js&lt;/li&gt;
  &lt;li&gt;a bunch other cool technologies&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;what-can-i-still-do-for-your-company-remotely&quot;&gt;What can I still do for your company (remotely)&lt;/h2&gt;

&lt;p&gt;In these challenging times we still believe your company can benefit from the services of StrongBrew.
The services listed below is something that I still do 1/5th of my time:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Code reviews&lt;/li&gt;
  &lt;li&gt;Pair programming sessions&lt;/li&gt;
  &lt;li&gt;Help you with the interview process of your possible employees&lt;/li&gt;
  &lt;li&gt;Help you with kickstarting a new project&lt;/li&gt;
  &lt;li&gt;Overal architectural support&lt;/li&gt;
  &lt;li&gt;Tackle very specific problems&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Unfortunately our company has died a slow death, but you will be hearing more of StrongBrew in the near future. Stay safe! Stay healthy! And if you have questions don’t hesitate to reach out.
Cheers! Brecht.&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Nov 2020 00:00:00 +0100</pubDate>
        <link>https://blog.brecht.io/how-covid-affected-strongbrew/</link>
        <guid isPermaLink="true">https://blog.brecht.io/how-covid-affected-strongbrew/</guid>
        
        <category>COVID</category>
        
        
        <category>Covid</category>
        
      </item>
    
      <item>
        <title>Managing state in Angular</title>
        <description>&lt;h2 id=&quot;about-this-article&quot;&gt;About this article&lt;/h2&gt;

&lt;p&gt;When we create single-page-applications, there is no way around it. Sooner or later we are going to be facing state. There are a lot of solutions out there to manage that state and together with those solutions there are a lot of opinions.
Especially when working with experienced developers, there opinions get stronger and often result in interesting discussions.&lt;/p&gt;

&lt;p&gt;This article is not about which libraries to use, but to learn about what state is and how we can reason about it. The examples are all written in Angular, however the approaches are not specific to Angular.&lt;/p&gt;

&lt;p&gt;In this article we will learn about the different kind of state types within our application, and where that state might live.&lt;/p&gt;

&lt;h2 id=&quot;what-is-state&quot;&gt;What is state?&lt;/h2&gt;

&lt;p&gt;State is basically everything that will define the UI that our user will be using.
State could be whether a button should be visible or not, it could be the result of that button click and it could also be an &lt;code&gt;Array&lt;/code&gt; of users that is coming from an API.
State can live in different places throughout our entire application. Some state is very specific to a certain component where other state might be shared in different parts of our application. One piece of state could be a singleton instance, where a another piece of state could share the limited lifespan of a component that can be destroyed at any time.&lt;/p&gt;

&lt;p&gt;This big variety of what state could be, how long it lives and where it comes from results in complexity that we need to manage.&lt;/p&gt;

&lt;h2 id=&quot;what-is-state-management&quot;&gt;What is state management?&lt;/h2&gt;

&lt;p&gt;State management is the concept of adding, updating, removing and reading pieces of state in an application. When we have deeply nested data structures and we want to update a specific part deep down in the tree, it might become complex. In that case we have state management libraries that contain a &lt;code&gt;Store&lt;/code&gt; which helps us with state management to get rid of that complexity. A quick note, we have to be careful that these libraries don’t add complexity by overusing them.&lt;/p&gt;

&lt;h2 id=&quot;reactive-state&quot;&gt;Reactive state&lt;/h2&gt;

&lt;p&gt;Combining state management together with reactive programming can be a really nice way to develop single-page-applications. Whether our focus lies on Angular, Vue or React, combining these two principles  will result in more predictable applications.&lt;/p&gt;

&lt;p&gt;Now what has state to do with reactive programming?
A piece of state can change over time, so in a way we are waiting for new state changes. That makes it asynchronous.&lt;/p&gt;

&lt;p&gt;Let’s take this example for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// false------true-----false---true...
sidebarCollapsed$ = this.state.sidebarCollapsed$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;sidebarCollapsed$&lt;/code&gt; stream starts out with &lt;code&gt;false&lt;/code&gt;, later on it becomes &lt;code&gt;true&lt;/code&gt; and so on. This stream keeps on living. In Angular this state can be consumed with the &lt;a href=&quot;https://angular.io/api/common/AsyncPipe&quot;&gt;async pipe&lt;/a&gt; as easy as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;my-awesome-sidebar *ngIf=&quot;sidebarCollapsed$|async&quot;&amp;gt;
&amp;lt;/my-awesome-sidebar&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;async&lt;/code&gt; pipe will subscribe to the &lt;code&gt;sidebarCollapsed$&lt;/code&gt; pass it to the component, mark it for check and will automatically unsubscribe when the component gets destroyed.
Keeping state in an observer pattern is nice because we can subscribe to the changes. Oh, and did I mention it plays super nice with Angular?&lt;/p&gt;

&lt;p&gt;We can either use a &lt;code&gt;BehaviorSubject&lt;/code&gt; or state management frameworks that support Observables. Here are some really great ones with Observable support:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ngrx.io&quot;&gt;Ngrx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://netbasal.gitbook.io/akita/&quot;&gt;Akita&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ngxs/store&quot;&gt;Ngxs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;immutability-and-unidirectional-data-flow&quot;&gt;Immutability and Unidirectional data flow&lt;/h2&gt;

&lt;p&gt;Before we dive deeper in state, there are 2 important principles that we should follow when managing state.
The first principle is &lt;strong&gt;immutability&lt;/strong&gt;, which means that we should never mutate data directly without creating a new reference of that object.
If we mutate data directly, our application becomes unpredictable and it’s really hard to trace bugs.
When we work in an immutable fashion we can also take advantage of performance strategies like the &lt;a href=&quot;https://netbasal.com/a-comprehensive-guide-to-angular-onpush-change-detection-strategy-5bac493074a4&quot;&gt;ChangeDetection.OnPush&lt;/a&gt; from Angular or React its &lt;a href=&quot;https://reactjs.org/docs/react-api.html#reactpurecomponent&quot;&gt;PureComponent&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When we use typescript we can enforce the typescript compiler to complain when we mutate data&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;type Foo = {
    readonly bar: string; 
    readonly baz: number; 
}
let first = {bar: 'test', baz: 1};
first.bar = 'test2'; // compilation error
first = {...first, bar: 'test2'}; // success
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the previous example we have overwritten the &lt;code&gt;first&lt;/code&gt; instance with an entire new instance that has an updated &lt;code&gt;bar&lt;/code&gt; property.&lt;/p&gt;

&lt;p&gt;Arrays can be handled like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;let arr = ['Brecht', 'Kwinten'];
arr.push('John'); // BAD: arr is mutated
arr = [...arr, 'John']; // Good, arr gets new reference
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the &lt;code&gt;Array&lt;/code&gt; prototype also has some great helper functions that we can use to enforce immutability like &lt;code&gt;map()&lt;/code&gt; and &lt;code&gt;filter()&lt;/code&gt; but this is not in scope for this article.&lt;/p&gt;

&lt;p&gt;The second principle is &lt;strong&gt;Unidirectional data flow&lt;/strong&gt;.
In a nutshell, this means that we should never use two-way data binding on state. It is the absolute owner of that specific piece of state that is in charge of updating it (immutable of course).&lt;/p&gt;

&lt;p&gt;Both of these principles are highly enforced by the &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; pattern.&lt;/p&gt;

&lt;h2 id=&quot;what-kind-of-states-are-there&quot;&gt;What kind of states are there?&lt;/h2&gt;

&lt;h3 id=&quot;router-state&quot;&gt;Router state&lt;/h3&gt;

&lt;p&gt;Often forgotten, but one of the most important pieces of state a web application can have. Putting state in the route gives us the following advantages:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We can use the browser navigation buttons&lt;/li&gt;
  &lt;li&gt;We can bookmark the state&lt;/li&gt;
  &lt;li&gt;We can can copy and paste the url with the state to other users&lt;/li&gt;
  &lt;li&gt;We don’t have to manage it, it’s always there in the route&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Tip&lt;/strong&gt;: Instead of handling modals with a &lt;code&gt;userDetailModalVisible&lt;/code&gt; property, why not enjoy all the benefits mentioned above and bind it to a &lt;code&gt;users/:userId&lt;/code&gt; route?
Using a child &lt;code&gt;router-outlet&lt;/code&gt; in Angular makes this a piece of cake as we can see in this snippet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;table&amp;gt;
&amp;lt;!--contains users --&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;router-outlet&amp;gt;
&amp;lt;!-- user detail modal rendered in here --&amp;gt;
&amp;lt;/router-outlet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;component-state&quot;&gt;Component state&lt;/h3&gt;

&lt;p&gt;Every component could contain state. That state could be shared with its dumb components or could be used in the component itself.
Eg: When an &lt;code&gt;ItemComponent&lt;/code&gt; has a property &lt;code&gt;selectedItems&lt;/code&gt; which is an array of ids, and that array is never used in other components (that aren’t children of that component), we can consider it component state. 
It belongs to that component, therefore the component should be responsible for it. Child components can consume that state but should &lt;em&gt;never mutate it&lt;/em&gt;. Those components can notify their parent that is responsible for it, which could update it in an immutable way. For more information about smart and dumb components &lt;a href=&quot;https://blog.strongbrew.io/components-demystified/#smart-vs-dumb-components&quot;&gt;look here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Personally, I try to avoid state management frameworks for managing component state because it’s the responsibility of that component to manage that state.
There are however good reasons to use state management frameworks to manage component state:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When the state management is very complex&lt;/li&gt;
  &lt;li&gt;If we want to do &lt;a href=&quot;https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/&quot;&gt;optimistic updates&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;If we want to use it for &lt;a href=&quot;https://blog.strongbrew.io/How-we-made-our-app-real-time-in-6-lines-of-code/&quot;&gt;realtime stuff&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If the state management of the component becomes a bit too complex and we don’t want to use a state management framework just yet, we could use a state reducer in the component itself.&lt;/p&gt;

&lt;h3 id=&quot;persisted-state&quot;&gt;Persisted state&lt;/h3&gt;

&lt;p&gt;Persisted state, is state that is being remembered when the user navigates between different pages. This could be whether a sidebar was collapsed or not, or when the user returns to a grid with a lot of filters and he wants them to be remembered and reapplied when he returns.
Another example is a wizard with different steps, and every step needs to be persisted so the user can navigate back and forth and the last page is a result of all these steps.&lt;/p&gt;

&lt;p&gt;Persisted state is the type of state where we typically use a state management framework for, that being said, if we don’t want to rely on an external dependency we can also manage it in a Angular &lt;code&gt;service&lt;/code&gt; which can be a singleton that is shared throughout the entire application. If that &lt;code&gt;service&lt;/code&gt; becomes too complex or there is a lot of state to manage, I would consider to put that state into a state management framework.&lt;/p&gt;

&lt;h3 id=&quot;shared-state&quot;&gt;Shared state&lt;/h3&gt;

&lt;p&gt;When we are talking about shared state, we are talking about state that needs to be shared between different parts of our application. State that is being shared throughout different smart components. This means that the instance of this piece of state should live on a higher level, than the components that want to consume it.&lt;/p&gt;

&lt;p&gt;Shared state can be managed in a state management framework like &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt;, &lt;a href=&quot;https://ngrx.io&quot;&gt;Ngrx&lt;/a&gt;, &lt;a href=&quot;https://netbasal.gitbook.io/akita/&quot;&gt;Akita&lt;/a&gt;, &lt;a href=&quot;https://github.com/ngxs/store&quot;&gt;Ngxs&lt;/a&gt; and so on, but if that state is small and simple we can also manage it manually.
Let’s say that we want an &lt;code&gt;Observable&lt;/code&gt; of an &lt;code&gt;Array&lt;/code&gt; of countries that we need to share throughout the entire application. In Angular we could have a &lt;code&gt;CountryService&lt;/code&gt; that fetches the countries from the API once, and then shares it throughout the entire application. 
For that we can use the &lt;code&gt;shareReplay&lt;/code&gt; operator from RxJS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;export class CountryService {
    ...
    countries$ = this.httpClient.get('countries').pipe(shareReplay(1));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simple right, one line of code?! For this we don’t &lt;strong&gt;need&lt;/strong&gt; a state management framework, although it can also have its benefits.
Some developers like to keep all their master data in a &lt;code&gt;Redux&lt;/code&gt; store, and that’s fine. Just know that we don’t have to.
I like to develop by the &lt;strong&gt;KISS&lt;/strong&gt; principle (&lt;strong&gt;K&lt;/strong&gt;eep &lt;strong&gt;I&lt;/strong&gt;t &lt;strong&gt;S&lt;/strong&gt;imple &lt;strong&gt;S&lt;/strong&gt;tupid) as much as possible, so I favor this approach many times.
Think about the amount of lines of code we saved by this approach.
Beware that every line of code we write, not only needs to be written but also maintained.&lt;/p&gt;

&lt;h2 id=&quot;which-state-needs-to-be-managed&quot;&gt;Which state needs to be managed?&lt;/h2&gt;

&lt;p&gt;Now that we know what state is, we have to ask ourselves which state needs to be managed, and where do we manage that state? In a component, singleton service or a framework (Store)?&lt;/p&gt;

&lt;p&gt;This is the part where the strong opinions surface.
I would suggest to use what works for you and your team and really think about, but here are  &lt;strong&gt;my personal opinionated&lt;/strong&gt; guidelines:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I try to avoid state management frameworks where possible. RxJS already leverages us with a lot already and I like to think &lt;strong&gt;KISS&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;I try to avoid using state management frameworks to communicate with different parts in my application, I believe state is unrelated to communication.&lt;/li&gt;
  &lt;li&gt;When my component can handle the state and it’s not too complex, I let my component in charge of managing that state.&lt;/li&gt;
  &lt;li&gt;Master data like countries are exposed in a service which uses the &lt;code&gt;shareReplay&lt;/code&gt; operator.&lt;/li&gt;
  &lt;li&gt;I don’t put the result of a &lt;code&gt;getById&lt;/code&gt; API call into a store if there is no one consuming that state except for the component requesting it&lt;/li&gt;
  &lt;li&gt;I use a facade between my smart components and my store/services to make refactoring easier in the future.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;However, there is also a popular opinion out there to put literally everything in the store which has the following advantages:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We can see the flow of the code in devtools&lt;/li&gt;
  &lt;li&gt;Consistent pattern&lt;/li&gt;
  &lt;li&gt;We can leverage selectors with memoization&lt;/li&gt;
  &lt;li&gt;Easier for realtime applications&lt;/li&gt;
  &lt;li&gt;Optimistic updates are easier&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;However, there are a few downsides as well:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A gigantic amount of bloat code: Bigger bundle size, more maintenance and dev time. Eg: If we would use the complete Ngrx pattern for the &lt;code&gt;countries$&lt;/code&gt; example we would have to write an: &lt;code&gt;action&lt;/code&gt;, &lt;code&gt;actiontype&lt;/code&gt;, &lt;code&gt;effect&lt;/code&gt; and a  &lt;code&gt;reducer&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Tightly coupled to a strong dependency that is hard to get rid of in the future&lt;/li&gt;
  &lt;li&gt;Generally more complex&lt;/li&gt;
  &lt;li&gt;The user his screen can get out of sync with the backend&lt;/li&gt;
  &lt;li&gt;Cache invalidation: if we add a &lt;code&gt;currentUserToEdit&lt;/code&gt; in the store, we have to get it out when we navigate away&lt;/li&gt;
  &lt;li&gt;We can’t use the &lt;code&gt;async&lt;/code&gt; pipe to cancel pending XHR requests&lt;/li&gt;
  &lt;li&gt;We create a distributed monolith of some sort&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;State management is a topic surrounded with discussions and opinions. There is no right or wrong, use what works for you and your team. There are awesome libraries out there, use them if it benefits you, but at least think about it before you use them. That’s the goal of this article after all, to get everyone to start thinking about state managment rather than jumping to the first solution.&lt;/p&gt;

&lt;h2 id=&quot;special-thanks&quot;&gt;Special thanks&lt;/h2&gt;

&lt;p&gt;Special thanks to the awesome reviewers:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/tim_deschryver&quot;&gt;Tim Deschryver&lt;/a&gt;
&lt;a href=&quot;https://twitter.com/jefiozie&quot;&gt;Jeffrey Bosch&lt;/a&gt;
&lt;a href=&quot;https://twitter.com/rubverm&quot;&gt;Ruben Vermeulen&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Jul 2019 00:00:00 +0200</pubDate>
        <link>https://blog.brecht.io/managing-state-in-angular/</link>
        <guid isPermaLink="true">https://blog.brecht.io/managing-state-in-angular/</guid>
        
        <category>architecture</category>
        
        
        <category>brechtbilliet</category>
        
      </item>
    
      <item>
        <title>A generic way of handling loading-status, saving-status and validation errors in Angular</title>
        <description>&lt;p&gt;When writing Angular applications there are always pieces of functionality that are being rewritten over and over again. 3 common usecases are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Showing a &lt;em&gt;loading&lt;/em&gt; status&lt;/li&gt;
  &lt;li&gt;Showing an &lt;em&gt;acting&lt;/em&gt; status (whether the user is adding, updating or removing data)&lt;/li&gt;
  &lt;li&gt;Showing validation errors&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this article we are going to implement a generic solution on how to fix these usecases.&lt;/p&gt;

&lt;h2 id=&quot;a-non-generic-way-of-loading-saving-and-handling-validation-errors-in-angular&quot;&gt;A non generic way of loading, saving and handling validation errors in Angular&lt;/h2&gt;

&lt;p&gt;Before we jump to the solution, let’s have a look at the impact of a non generic way of handling the previous called functionalities.
A solution that is often used might look like the following: (keep in mind that this functionality has to be implemented over and over again for every component)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;ngOnInit(): void {
    this.loading = true;
    const usersCompleted = false;
    const citiesCompleted = false;
    this.userService.fetch().subscribe(users =&amp;gt; {
        usersCompleted = true;
        this.loading = usersCompleted &amp;amp;&amp;amp; citiesCompleted;
    });
    this.citiesService.fetch().subscribe(cities =&amp;gt; {
        citiesCompleted = true;
        this.loading = usersCompleted &amp;amp;&amp;amp; citiesCompleted;
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have to keep track of which call completes first because we can’t set loading to false, if there is call still busy. What happens when there is an error? We would have to implement that as well.&lt;/p&gt;

&lt;p&gt;Now this code is only for fetching two lists of data, this becomes ugly pretty quickly and the worst thing about this is that we have to reimplement that for every component that does data fetching.&lt;/p&gt;

&lt;p&gt;It becomes even worse if we want to update, add and remove data. Imagine that we have to handle validation errors as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;remove(user: User): void {
    // TODO: set acting to true
    this.userService.remove(user).subscribe(res =&amp;gt; {
        // TODO: set acting to false
    });
}
update(user: User): void {
    // TODO: set acting to true
    this.userService.update(user).subscribe(res =&amp;gt; {
        // TODO: set acting to false
        // TODO: handle validation errors
    });
}
add(user: User): void {
    // TODO: set acting to true
    this.userService.add(user).subscribe(res =&amp;gt; {
        // TODO: set acting to false
        // TODO: handle validation errors
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To handle validation errors we have to check if the HTTP status code is 400, manually map the data etc.&lt;/p&gt;

&lt;p&gt;These code samples are in this article to prove a point. &lt;strong&gt;It’s dirty redundant logic that we have to implement over and over again&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;lets-clean-this-up&quot;&gt;Let’s clean this up&lt;/h2&gt;

&lt;p&gt;To achieve this we will use an Angular &lt;em&gt;service&lt;/em&gt; in combination with an angular &lt;em&gt;interceptor&lt;/em&gt; and Typescript &lt;em&gt;decorators&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The first thing we need is a &lt;code&gt;HttpStatusService&lt;/code&gt; that exposes 3 observables:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;loading$&lt;/code&gt;: whether the user is fetching data&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;acting$&lt;/code&gt;: whether the user is removing, updating or adding data&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;validationErrors$&lt;/code&gt;: whether there are validation errors or not&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// http-status.service.ts
@Injectable({
  // important to provide this service to the 
  // injector of the root module 
  providedIn: 'root'
})
export class HttpStatusService {
  // regular subject because we don't want to replay
  // the validationerrors
  private validationErrorsSub$ 
    = new Subject&amp;lt;ValidationError[]&amp;gt;();

  // 2 subjects that replays the last value 
  // (ideal for state)
  private loadingSub$ = new ReplaySubject&amp;lt;boolean&amp;gt;(1);
  private actingSub$ = new ReplaySubject&amp;lt;boolean&amp;gt;(1);

  // we don't want to expose the subject for
  // encapsulation purposes. That's why we convert them
  // into observables
  getvalidationErrors$ = 
    this.validationErrorsSub$.asObservable();
  loading$ = 
    this.loadingSub$.pipe(distinctUntilChanged());
  acting$ = 
    this.actingSub$.pipe(distinctUntilChanged());

  // these are just some regular setters to next 
  // the values in our subjects
  set validationErrors(errors: ValidationError[]) {
    this.validationErrorsSub$.next(errors);
  }

  set loading(val: boolean) {
    this.loadingSub$.next(val);
  }

  set acting(val: boolean) {
    this.actingSub$.next(val);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we have a service that basically holds the state of our three statuses.
Now we still have to make sure that the setters of these observables are being called at the right place and the right time.
We don’t want to manually implement that for every call, so let’s create an interceptor for that.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;@Injectable({
    providedIn: 'root'
})
export class HttpStatusInterceptor implements HttpInterceptor {
  // keep track of the loading calls
  private loadingCalls = 0; 
  // keep track of the acting calls
  private actingCalls = 0; 

  constructor(
    private httpStatusService: HttpStatusService
  ) {}

  private changeStatus(val: boolean, method: string): void {
    if (['POST', 'PUT', 'DELETE', 'PATCH']
      .indexOf(method) &amp;gt; -1) {
      val ? this.actingCalls++ : this.actingCalls--;
      this.httpStatusService.acting = this.actingCalls &amp;gt; 0;
    } else if (method === 'GET') {
      val ? this.loadingCalls++ : this.loadingCalls--;
      this.httpStatusService.loading = this.loadingCalls &amp;gt; 0;
    }
  }
  ...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see, we have created a private &lt;code&gt;changeStatus()&lt;/code&gt; function that will use the &lt;code&gt;loading&lt;/code&gt; and &lt;code&gt;acting&lt;/code&gt; 
setters of our &lt;code&gt;HttpStatusInterceptor&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;If the HTTP-method is &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; or &lt;code&gt;PATCH&lt;/code&gt; we have to update the counter of the &lt;code&gt;actingCalls&lt;/code&gt; and if that count is bigger then 0, it means the user is acting and we have to update the &lt;code&gt;acting&lt;/code&gt; property of the &lt;code&gt;HttpStatusService&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If the HTTP-method is &lt;code&gt;GET&lt;/code&gt; it should do the same for the &lt;code&gt;loadingCalls&lt;/code&gt; property and &lt;code&gt;loading&lt;/code&gt; setter of the &lt;code&gt;HttpStatusService&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course we still have to implement the &lt;code&gt;intercept&lt;/code&gt; function. Every time we intercept a call we have to change a status to &lt;code&gt;true&lt;/code&gt;.
Because this means that the user is loading or acting.
The goal of an interceptor is to intercept a request, clone that request, do something with it and return it.
The &lt;code&gt;handle&lt;/code&gt; function of the &lt;code&gt;HttpHandler&lt;/code&gt; returns an observable. This is the perfect place to apply a &lt;code&gt;finalize&lt;/code&gt; operator,
which we can use to set a status to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;...
intercept(
  req: HttpRequest&amp;lt;any&amp;gt;,
  next: HttpHandler
): Observable&amp;lt;HttpEvent&amp;lt;any&amp;gt;&amp;gt; {
  // there is a new request, so we are definitely
  // loading or acting, we have to change the status
  this.changeStatus(true, req.method);
  return next.handle(req.clone()).pipe(
    // when the request completes, errors or times out,
    // we have to change the status as well
    finalize(() =&amp;gt; {
      this.changeStatus(false, req.method);
    })
  );
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should automatically update the &lt;code&gt;loading$&lt;/code&gt; and &lt;code&gt;acting$&lt;/code&gt; observables in the &lt;code&gt;HttpStatusService&lt;/code&gt;.
However, we have not fixed our validation errors issue yet. For that we can use the &lt;code&gt;catchError&lt;/code&gt; operator that we place before the finalize operator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;intercept(
  req: HttpRequest&amp;lt;any&amp;gt;,
  next: HttpHandler
): Observable&amp;lt;HttpEvent&amp;lt;any&amp;gt;&amp;gt; {
  ..
  return next.handle(req.clone()).pipe(
    // catch the error
    catchError(e =&amp;gt; {
      // if bad request &amp;gt; validation erors
      if (e.status === 400) { 
        // use the validationErrors setter to update
        this.httpStatusService.validationErrors = 
          e.error.validationErrors;
        // make sure that this result never 
        // reaches the component
        return NEVER;
      }
      // throw the error back
      // or put that in the `HttpStatusService` as well ;-)      
      return throwError(e); 
    }),
    finalize(...)
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The entire interceptor class looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;@Injectable({
    providedIn: 'root'
})
export class HttpStatusInterceptor implements HttpInterceptor {
  private loadingCalls = 0; 
  private actingCalls = 0; 

  constructor(
    private httpStatusService: HttpStatusService
  ) {}

  private changeStatus(v: boolean, method: string): void {
    if (['POST', 'PUT', 'DELETE', 'PATCH']
      .indexOf(method) &amp;gt; -1) {
      v ? this.actingCalls++ : this.actingCalls--;
      this.httpStatusService.acting = this.actingCalls &amp;gt; 0;
    } else if (method === 'GET') {
      v ? this.loadingCalls++ : this.loadingCalls--;
      this.httpStatusService.loading = this.loadingCalls &amp;gt; 0;
    }
  }

  intercept(
    req: HttpRequest&amp;lt;any&amp;gt;,
    next: HttpHandler
  ): Observable&amp;lt;HttpEvent&amp;lt;any&amp;gt;&amp;gt; {
    return next.handle(req.clone()).pipe(
      catchError(e =&amp;gt; {
        if (e.status === 400) { 
          this.httpStatusService.validationErrors = 
            e.error.validationErrors;
          return NEVER;
        }
        return throwError(e); 
      }),
      finalize(() =&amp;gt; {
        this.changeStatus(false, req.method);
      })
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When registering the interceptor to the root module, the observables in the &lt;code&gt;HttpStatusService&lt;/code&gt; will be updated automatically.&lt;/p&gt;

&lt;p&gt;So in the rootModule we have to add the following code to the &lt;code&gt;providers&lt;/code&gt; property of the &lt;code&gt;@NgModule&lt;/code&gt; decorator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;providers: [
  ...
  {
    provide: HTTP_INTERCEPTORS,
    multi: true,
    deps: [HttpStatusService],
    useClass: HttpStatusInterceptor
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now use the &lt;code&gt;HttpStatusService&lt;/code&gt; in our code as easy as this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;export class UserComponent {
  loading$ = this.httpStatus.loading;
  validationErrors$ = this.httpStatus.validationErrors;
  acting$ = this.httpStatus.loading;

  constructor(
    private httpStatusService: HttpStatusService) {
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have 3 observables that can easily be consumed in the template of the component with the use of the &lt;a href=&quot;https://angular.io/api/common/AsyncPipe&quot;&gt;async&lt;/a&gt; pipe. Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;my-spinner *ngIf=&quot;loading$ | async&quot;&amp;gt;&amp;lt;/my-spinner&amp;gt;
&amp;lt;my-user-form 
    [validationErrors]=&quot;validationErrors$ | async&quot;
    [disabled]=&quot;acting$ | async&quot;&amp;gt;&amp;lt;/my-user-form&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;optimizing-with-decorators&quot;&gt;Optimizing with decorators&lt;/h2&gt;

&lt;p&gt;We have cleaned up a lot, we found an easy way to get the httpstatuses to the component, but we can make it even simpler with the use of decorators. let’s refactor the &lt;code&gt;UserComponent&lt;/code&gt; class accordingly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;export class UserComponent {
  @Loading()loading$;
  @ValidationErrors() validationErrors$;
  @Acting() acting$;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is very declarative way of working. The component is way cleaner and we don’t have to inject the &lt;code&gt;HttpStatusService&lt;/code&gt; anymore.&lt;/p&gt;

&lt;p&gt;But how do we create these decorators? I’m glad you asked, it’s pretty easy. A property decorator is simply a function that returns a function that gets the target and key as arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;export function Loading() {
  return function (target: any, key: string): void {
    // in this case the target is the component
    // instance and key the property name
    // target: userComponent, key: loading$
    // now we have to set the property to the actual 
    // loading$ observable that lives in the HttpStatusService
    target[key] = // todo
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To set the property of the target we need to inject the &lt;code&gt;HttpStatusService&lt;/code&gt; instance that is registered on the root injector of our application. After all that’s the instance that contains the actual state. Currently there is no easy way to do that.
Until Angular provides us with functionality like &lt;a href=&quot;https://github.com/angular/angular/issues/23301&quot;&gt;that&lt;/a&gt; we can use the following solution:&lt;/p&gt;

&lt;p&gt;Next to the &lt;code&gt;http-status.service&lt;/code&gt; file, create a file called &lt;code&gt;root-injector.ts&lt;/code&gt; and add the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;import { Injector } from '@angular/core';

export let rootInjector: Injector;
export function setRootInjector(injector: Injector): void {
  rootInjector = injector;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;setRootInjector()&lt;/code&gt; function will be used by the rootModule to set the &lt;code&gt;rootInjector&lt;/code&gt; variable that we expose here.
To make it work the rootModule will have to call the &lt;code&gt;setRootInjector()&lt;/code&gt; function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;@NgModule({
    ...
})
export class AppModule {
  constructor(private injector: Injector) {
    setRootInjector(injector);
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step is to actually use the &lt;code&gt;rootInjector&lt;/code&gt; variable inside the decorators. The result looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// loading.decorator.ts
export function Loading() {
  return function (target: any, key: string): void {
    const service = rootInjector.get(HttpStatusService);
    target[key] = service.loading$;
  }
};

// acting.decorator.ts
export function Acting() {
  return function (target: any, key: string): void {
    const service = rootInjector.get(HttpStatusService);
    target[key] = service.acting$;
  }
};

// validation-errors.decorator.ts
export function ValidationErrors() {
  return function (target: any, key: string): void {
    const service = rootInjector.get(HttpStatusService);
    target[key] = service.validationErrors$;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We have learned that we can remove the redundancy that comes with loading, acting and error handling statuses almost completely by the use of an interceptor, a simple service and a few decorators.&lt;/p&gt;

&lt;p&gt;I hope you liked it!&lt;/p&gt;

&lt;h2 id=&quot;special-thanks&quot;&gt;Special thanks&lt;/h2&gt;

&lt;p&gt;A very special thanks to the reviewers:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/bobrov1989&quot;&gt;Vitallii Bobrov (@bobrov1989)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/webdave_de&quot;&gt;David Müllerchen (@webdave_de)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/maartentibau&quot;&gt;Maarten Tibau (@maartentibau)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/elmd_&quot;&gt;Dominic Elm (@elmd_)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/fabiangosebrink&quot;&gt;Fabian Gosebrink (@FabianGosebrink)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 25 Jan 2019 00:00:00 +0100</pubDate>
        <link>https://blog.brecht.io/generic-way-of-handling-loading-saving-and-validationerrors-in-angular/</link>
        <guid isPermaLink="true">https://blog.brecht.io/generic-way-of-handling-loading-saving-and-validationerrors-in-angular/</guid>
        
        <category>Angular</category>
        
        <category>Architecture</category>
        
        <category>errorhandling</category>
        
        <category>interceptors</category>
        
        <category>decorators</category>
        
        
        <category>angular</category>
        
      </item>
    
      <item>
        <title>Opinionated guidelines for large nx angular projects</title>
        <description>&lt;h2 id=&quot;about-this-article&quot;&gt;About this article&lt;/h2&gt;

&lt;p&gt;This article contains a set of opinionated guidelines when it comes to building monorepos with &lt;a href=&quot;https://nrwl.io/nx&quot;&gt;Nx&lt;/a&gt;.
I wrote this article because when I used Nx in the beginning, I struggled a lot with how to structure my workspace, and I’ve hit quite a few walls. That being said, I’ve been using it for a while now, and I finally have the feeling that I’ve reached a structure where I feel comfortable with.&lt;/p&gt;

&lt;h2 id=&quot;a-word-about-nx&quot;&gt;A word about Nx&lt;/h2&gt;

&lt;p&gt;Nx is a thin layer on top of the &lt;a href=&quot;https://angular.io&quot;&gt;Angular&lt;/a&gt; CLI that helps us with structuring large applications in the form of monorepos.
A monorepo contains only one &lt;a href=&quot;https://nrwl.io/nx/guide-nx-workspace&quot;&gt;Nx workspace&lt;/a&gt; that can contain multiple apps and multiple libs (we will refer to apps and libs as Nx projects). An app is a deployable unit and a lib is meant to contain the actual logic that can be shared across the workspace. Nx is actively being developed and updated along with Angular by the amazing people of &lt;a href=&quot;https://nrwl.io/&quot;&gt;Nrwl&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Nx is especially valuable when managing &lt;strong&gt;big Angular applications&lt;/strong&gt; that have a lot of shared functionality, but even in smaller projects it can help organize your approach.&lt;/p&gt;

&lt;p&gt;At StrongBrew we are using this technology for a bunch of our clients and even though Nx is already pretty opinionated, I decided to write down some best practices and guidelines that I try to take in consideration.&lt;/p&gt;

&lt;p&gt;The rules and guidelines written down in this article &lt;strong&gt;might work for you&lt;/strong&gt;, and should in no circumstances be treated as the &lt;em&gt;ultimate truth&lt;/em&gt;. Best practices and guidelines are mostly a matter of perception and personal preference. Nevertheless, I would love to share how I architect large Angular applications with Nx.&lt;/p&gt;

&lt;h2 id=&quot;barrel-files&quot;&gt;Barrel files&lt;/h2&gt;

&lt;p&gt;When it comes to managing monorepos, barrel files are quite important.
A barrel file is a &lt;code&gt;index.ts&lt;/code&gt; file that lives in the &lt;code&gt;src&lt;/code&gt; directory of every Nx lib and is meant to expose logic to the rest of the workspace.&lt;/p&gt;

&lt;p&gt;This file is really important when you understand one of the big potential risks of organizing code in monorepos - overexposure of implementation details.&lt;/p&gt;

&lt;p&gt;With code being located right next to each other, it can be easy to import code with deeply nested relative paths and include things that the original author of the code never intended to be used outside of their specific context.&lt;/p&gt;

&lt;p&gt;The Nx lib’s &lt;code&gt;index.ts&lt;/code&gt; file allows each lib to define its effective public API - only symbols which are explicitly exported from this file should be eligible for consumption in other parts of the workspace.&lt;/p&gt;

&lt;p&gt;Let’s say that we have a &lt;code&gt;@strongbrew/users&lt;/code&gt; lib which exposes a &lt;code&gt;UserService&lt;/code&gt;…
This is what the barrel file from  &lt;code&gt;@strongbrew/users&lt;/code&gt; might look like.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// libs/users/src/index.ts
export * from './lib/services/user.service';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although this might seem pretty straight forward, let’s go over a few best-practices…&lt;/p&gt;

&lt;h3 id=&quot;dont-ever-import-a-lib-from-a-relative-path&quot;&gt;Don’t ever import a lib from a relative path&lt;/h3&gt;

&lt;p&gt;When we want to import &lt;code&gt;UserService&lt;/code&gt; inside another lib or app, we want to import it from &lt;code&gt;@strongbrew/users&lt;/code&gt;. This is way cleaner then importing it from a relative path like &lt;code&gt;../../../users/lib/src/index.ts&lt;/code&gt; and helps protect us from the overexposure problem described above. Nx also provides a linting rule out of the box to make sure that you are respecting a lib’s API and not doing deep imports.&lt;/p&gt;

&lt;p&gt;Nx uses TypeScript &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping&quot;&gt;path mapping&lt;/a&gt; to map these module names to the correct barrel files.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;paths&quot;: {
    &quot;@strongbrew/users&quot;: {
        &quot;libs/users/src/index.ts&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;only-1-barrel-file-per-lib&quot;&gt;Only 1 barrel file per lib&lt;/h3&gt;

&lt;p&gt;It’s a known fact that barrel files might become big, but it gives us a central place of handling all the exports + it drastically reduces the chance of getting circular reference errors. Therefore, a lib should only contain 1 single barrel file.&lt;/p&gt;

&lt;h3 id=&quot;never-let-a-lib-import-from-its-own-barrel-file&quot;&gt;Never let a lib import from its own Barrel file&lt;/h3&gt;

&lt;p&gt;The TypeScript modules within a particular lib should not care what functionality that lib exposes, so it shouldn’t use its own barrel file at any point.&lt;/p&gt;

&lt;p&gt;If a module imports something from its own barrel file, it almost always results in circular reference errors. Therefore, imports from inside of the module should use relative path imports.&lt;/p&gt;

&lt;h2 id=&quot;structuring-the-workspace&quot;&gt;Structuring the workspace&lt;/h2&gt;

&lt;p&gt;When using Nx, we might already get pushed in an opinionated way of working, which is great. But how are we going to structure the workspace itself? For instance, looking into a directory of 100 libs inside of a libs directory might not really be pragmatic to work with…&lt;/p&gt;

&lt;h3 id=&quot;structuring-apps&quot;&gt;Structuring apps&lt;/h3&gt;

&lt;h4 id=&quot;an-app-should-be-an-empty-shell&quot;&gt;An app should be an empty shell&lt;/h4&gt;

&lt;p&gt;Apps are deployable units that wire the different pieces of an application together. These apps are nearly empty shells that use libs to build an entire application. Therefore &lt;strong&gt;an app holds almost no logic&lt;/strong&gt; and mostly uses lazy loading to load feature libs. Some feature libs can be seen as microfrontends.
That being said, our apps mostly not completely empty. In general they also contain:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The general layout (composed out of components from ‘ui-kit’)&lt;/li&gt;
  &lt;li&gt;Routing&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;keep-the-apps-directory-as-flat-as-possible&quot;&gt;Keep the apps directory as flat as possible&lt;/h4&gt;

&lt;p&gt;Chances are small that our monorepo will contain 100+ apps and even if it does, chances are small that we can divide these apps into categories.&lt;/p&gt;

&lt;h4 id=&quot;apps-should-not-import-from-other-apps&quot;&gt;Apps should not import from other apps&lt;/h4&gt;

&lt;p&gt;Although it might seem obvious, let’s mention it anyway… Shared logic should always live inside of libs, an not inside of apps. Apps are specific deployment targets.&lt;/p&gt;

&lt;h3 id=&quot;structuring-libs&quot;&gt;Structuring libs&lt;/h3&gt;

&lt;p&gt;Here comes the opinionated part, lets check how we can structure the libs inside of our workspace.&lt;/p&gt;

&lt;p&gt;The directory structure of our workspace might look like this:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;apps&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;libs&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;feature&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;code&gt;api&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code&gt;foo&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;…&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code&gt;lazy&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code&gt;bar&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;…&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code&gt;shared&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code&gt;baz&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;…&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code&gt;ui-kit&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;utils&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;A feature contains logic specific to a certain domain, like managing users or performing authentication.&lt;/li&gt;
  &lt;li&gt;On the other hand, the &lt;code&gt;utils&lt;/code&gt; lib contains logic that doesn’t have anything to do with any domain, E.g: HTTP interceptors, shared RxJS operators, a service that handles notifications etc… Consider it a toolkit for your workspace.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the next few sections we are going to cover the 3 types of feature libs, the &lt;code&gt;ui-kit&lt;/code&gt; lib and the &lt;code&gt;utils&lt;/code&gt; lib.&lt;/p&gt;

&lt;h4 id=&quot;featureapi&quot;&gt;feature/api&lt;/h4&gt;

&lt;p&gt;This directory contains Nx libs with a very specific purpose:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;These libs contain &lt;strong&gt;api logic&lt;/strong&gt; or &lt;strong&gt;business logic&lt;/strong&gt; that needs to be shared.&lt;/li&gt;
  &lt;li&gt;These libs contain the types of the REST responses. Let’s call them &lt;strong&gt;domain types&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;If we want to work with models, or dto’s, these would also live here.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Having a specific api lib is very handy when developing in a microservices platform. Every microservice would have its own &lt;strong&gt;api lib&lt;/strong&gt; that can be used throughout the entire monorepo.&lt;/p&gt;

&lt;p&gt;Another common use-case is that feature libs tend to use domain types from other feature libs. By extracting these domain types in to api libs, we solve that problem. That way, these domain types can be shared across different places inside of the monorepo.&lt;/p&gt;

&lt;h4 id=&quot;featurelazy&quot;&gt;feature/lazy&lt;/h4&gt;

&lt;p&gt;This directory contains all feature libs that can be lazyloaded. To make sure these libs can be lazy-loaded, they should expose an &lt;code&gt;NgModule&lt;/code&gt; in the barrel file and are loaded as such:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;RouterModule.forRoot([
    {
        path: 'users',
        loadChildren: '@strongbrew/feature/lazy/users'
    }
])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the advantages is that these modules can be loaded on demand or even preloaded upfront. The biggest advantage though is that these modules are completely standalone, and don’t share anything with the rest of the workspace. This means they have nothing inside of their barrel file, other then the &lt;code&gt;NgModule&lt;/code&gt; being exported. 
&lt;strong&gt;Lazy loaded modules can never share logic with the workspace&lt;/strong&gt;
If we feel that a lazyloaded module needs to export something, we should extract that logic into a separate &lt;code&gt;feature/shared&lt;/code&gt; or &lt;code&gt;feature/api&lt;/code&gt; lib.&lt;/p&gt;

&lt;p&gt;When a &lt;code&gt;feature/lazy&lt;/code&gt; module needs to perform XHR calls it should delegate it to a &lt;code&gt;feature/api&lt;/code&gt; lib. Therefore a &lt;code&gt;feature/lazy&lt;/code&gt; lib should never contain api logic.&lt;/p&gt;

&lt;p&gt;When using a statemanagement library like &lt;a href=&quot;https://github.com/ngrx/platform&quot;&gt;ngrx/store&lt;/a&gt;, &lt;code&gt;feature/lazy&lt;/code&gt; libs would contain their own reducers and use &lt;code&gt;store.forFeature()&lt;/code&gt; to attach these to the &lt;code&gt;store&lt;/code&gt; instance. This would result in lazy-loaded reducers.&lt;/p&gt;

&lt;h4 id=&quot;featureshared&quot;&gt;feature/shared&lt;/h4&gt;

&lt;p&gt;Not every feature can be lazyloaded. Think about feature logic that needs to be shared for instance. In that case we would create an Nx lib that lives inside of the &lt;code&gt;feature/shared&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;When a &lt;code&gt;feature/shared&lt;/code&gt; module needs to perform XHR calls it should delegate it to a &lt;code&gt;feature/api&lt;/code&gt; lib. Therefore the &lt;code&gt;feature/lazy&lt;/code&gt; lib should not contain api logic.&lt;/p&gt;

&lt;h4 id=&quot;ui-kit&quot;&gt;ui-kit&lt;/h4&gt;

&lt;p&gt;This lib contains all the shared presentational components that can be used in different applications. Think about dropdowns, datepickers and empty modals. A &lt;code&gt;user-detail&lt;/code&gt; component for instance does NOT belong here. A monorepo can contain multiple &lt;code&gt;ui-kit&lt;/code&gt; libraries. We should name them according to its purpose. E.g &lt;code&gt;ui-kit-mobile&lt;/code&gt; is a common use case.&lt;/p&gt;

&lt;p&gt;The Ui-kit module contains an &lt;code&gt;ngModule&lt;/code&gt; since we need it to declare and export our components/directives. The barrel file generally only exposes the &lt;code&gt;ngModule&lt;/code&gt; since this is the vessel used to export the functionality.&lt;/p&gt;

&lt;p&gt;However, a &lt;code&gt;ui-kit&lt;/code&gt; might also export certain types in its barrel file… Like &lt;code&gt;DatepickerConfiguration&lt;/code&gt; or other &lt;code&gt;ui-kit&lt;/code&gt; specific types.&lt;/p&gt;

&lt;h4 id=&quot;utils&quot;&gt;utils&lt;/h4&gt;

&lt;p&gt;This lib can contain all kinds of utilities. It could contain shared interceptors, guards, services and custom RxJS operators. Think about it als a framework toolbox that could benefit any application. We will NOT use an &lt;code&gt;ngModule&lt;/code&gt; here for tree-shaking purposes.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;utils&lt;/code&gt; lib will not contain any components. But if it contains pipes or directives we might need an &lt;code&gt;ngModule&lt;/code&gt; for that.&lt;/p&gt;

&lt;p&gt;When your workspace is small, one single &lt;code&gt;utils&lt;/code&gt; lib might suffice, but it could become a good idea to split these up when the &lt;code&gt;utils&lt;/code&gt; lib gets to big.&lt;/p&gt;

&lt;p&gt;After splitting up, the directory structure of our workspace might look like this:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;apps&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;libs&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;feature&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;code&gt;api&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code&gt;foo&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;…&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code&gt;lazy&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code&gt;bar&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;…&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code&gt;shared&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code&gt;baz&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;…&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code&gt;ui-kit&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;utils&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;code&gt;rxjs-operators&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;forms&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;http&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Do note, that the &lt;code&gt;forms&lt;/code&gt; lib would not contain any forms or forms configuration, but it would contain general form logic that can be shared across the workspace.&lt;/p&gt;

&lt;h3 id=&quot;prefixing-libs&quot;&gt;Prefixing libs&lt;/h3&gt;

&lt;p&gt;Because of the fact that &lt;code&gt;selector&lt;/code&gt; names for components and directives should be unique, prefixing them in a monorepo is quite important. 
Since every project in the &lt;code&gt;angular.json&lt;/code&gt; file has a &lt;code&gt;prefix&lt;/code&gt; property, we could set that prefix for every project.&lt;/p&gt;

&lt;p&gt;Let’s assume that we need a &lt;code&gt;feature/shared&lt;/code&gt; lib called &lt;code&gt;messages&lt;/code&gt; then we could generate that lib by running &lt;code&gt;ng g lib messages --prefix sh-mes&lt;/code&gt; for instance. 
&lt;code&gt;sh-mes&lt;/code&gt; would be the prefix and if we create a message component in this lib it would have the selector: &lt;code&gt;sh-mes-message&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;linting-and-tags&quot;&gt;Linting and tags&lt;/h2&gt;

&lt;p&gt;One thing that is absolutely critical when managing a monorepo is being able to determine, categorize, and constrain/run commands based on a dependency graph.&lt;/p&gt;

&lt;p&gt;Nx determines the dependency graph for us out of the box, it infers it by statically analyzing our TypeScript import and export statements (as well as a few other things specific to the Angular CLI).&lt;/p&gt;

&lt;p&gt;It has no way of automatically categorizing the dependency graph for it, because that is up to our subjective judgement, but it does provide helpers to make it easy.&lt;/p&gt;

&lt;p&gt;Nx provides us with the ability to add tags to the different libs and apps and apply &lt;a href=&quot;https://palantir.github.io/tslint/&quot;&gt;tslint&lt;/a&gt; rules to make sure we can’t import whatever we want wherever we want.	Nx provides us with the ability to add tags to the different libs and apps and apply &lt;a href=&quot;https://palantir.github.io/tslint/&quot;&gt;tslint&lt;/a&gt; rules to make sure we can’t import whatever we want wherever we want (potentially leading to circular references and other problems (broken lazyloading, etc…)).&lt;/p&gt;

&lt;p&gt;Tags can be added to projects in the &lt;code&gt;nx.json&lt;/code&gt; file of the root directory.
Tags can be determined in numerous ways. Some of us might like a tag per team, other might like it per domain.&lt;/p&gt;

&lt;p&gt;I like to have tags for every lib type. It might be opinionated but it works fine for me (again, that’s a matter of personal preference)&lt;/p&gt;

&lt;p&gt;We define 5 types of tags:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;app&lt;/code&gt;: This tag is added to all the apps&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;shared&lt;/code&gt;: This tag is added to &lt;code&gt;uikit&lt;/code&gt; and &lt;code&gt;utils&lt;/code&gt; libs&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;feature:lazy&lt;/code&gt;: This tag is added to &lt;code&gt;feature/lazy&lt;/code&gt; libs&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;feature:shared&lt;/code&gt;: This tag is added to &lt;code&gt;feature/shared&lt;/code&gt; libs&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;feature:api&lt;/code&gt;: This tag is added to &lt;code&gt;feature/api&lt;/code&gt; libs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The rules could be the same for every workspace that we will create in the future:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Projects with the type &lt;code&gt;tag&lt;/code&gt; can only depend on projects with the tags: &lt;code&gt;shared&lt;/code&gt; or &lt;code&gt;feature:shared&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Projects with the type &lt;code&gt;shared&lt;/code&gt; can only depend on projects with the tags: &lt;code&gt;shared&lt;/code&gt; (we don’t want to import domain specific logic in there do we?)&lt;/li&gt;
  &lt;li&gt;Projects with the type &lt;code&gt;feature:lazy&lt;/code&gt; can only depend on projects with the tags: &lt;code&gt;shared&lt;/code&gt;, &lt;code&gt;feature:shared&lt;/code&gt; and &lt;code&gt;feature:api&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Projects with the type: &lt;code&gt;feature:shared&lt;/code&gt; can only depend on projects with the tags: &lt;code&gt;shared&lt;/code&gt; and &lt;code&gt;feature:api&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Projects with the type: &lt;code&gt;feature:api&lt;/code&gt; can only depend on projects with the tags: &lt;code&gt;feature:api&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt;. (we never want to load &lt;code&gt;feature:shared&lt;/code&gt; into an feature/api lib right?)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;configuring-tslint&quot;&gt;Configuring tslint&lt;/h3&gt;

&lt;p&gt;To configure the tslint we have to use the &lt;code&gt;nx-enforce-module-boundaries&lt;/code&gt; rule from tslint. If you like the rules defined above, you can just copy-paste the module boundaries defined below right in your &lt;code&gt;tslint.json&lt;/code&gt; file that lives in the root directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&quot;nx-enforce-module-boundaries&quot;: [
  true,
    {
      &quot;allow&quot;: [],
      &quot;depConstraints&quot;: [
      {
        &quot;sourceTag&quot;: &quot;app&quot;,
        &quot;onlyDependOnLibsWithTags&quot;: [&quot;shared&quot;, &quot;feature:shared&quot;]
      },
      {
        &quot;sourceTag&quot;: &quot;shared&quot;,
        &quot;onlyDependOnLibsWithTags&quot;: [&quot;shared&quot;]
      },
      {
        &quot;sourceTag&quot;: &quot;feature:lazy&quot;,
        &quot;onlyDependOnLibsWithTags&quot;: [
          &quot;shared&quot;,
          &quot;feature:shared&quot;,
          &quot;feature:api&quot;
        ]
      },
      {
        &quot;sourceTag&quot;: &quot;feature:api&quot;,
        &quot;onlyDependOnLibsWithTags&quot;: [&quot;feature:api&quot;, &quot;shared&quot;]
      },
      {
        &quot;sourceTag&quot;: &quot;feature:shared&quot;,
        &quot;onlyDependOnLibsWithTags&quot;: [&quot;shared&quot;, &quot;feature:api&quot;]
      }
      ]
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tslint config will ensure that the rules defined above are mandatory.&lt;/p&gt;

&lt;h2 id=&quot;is-this-structure-the-only-way&quot;&gt;Is this structure the only way?&lt;/h2&gt;

&lt;p&gt;No, not at all, this would work perfectly for a monorepo with 5 applications. But if we are thinking about organisation wide monorepos, it might be a good idea to
combine features app per app. In that case we would have something like:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;apps&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;libs&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;app1&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;code&gt;api&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code&gt;foo&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;…&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code&gt;lazy&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code&gt;bar&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;…&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code&gt;shared&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code&gt;baz&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;…&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code&gt;app2&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;code&gt;api&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code&gt;foo&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;…&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code&gt;lazy&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code&gt;bar&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;…&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code&gt;shared&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code&gt;baz&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;…&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code&gt;ui-kit&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;utils&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;code&gt;rxjs-operators&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;forms&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;http&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;how-to-share-code-organisation-wide&quot;&gt;How to share code organisation wide?&lt;/h2&gt;

&lt;p&gt;Although an organisation wide monorepo has great benefits, they might be good reasons not to do it. These could be any combination of technical, cultural, legal or other reasons.&lt;/p&gt;

&lt;h3 id=&quot;scenario-a&quot;&gt;Scenario A&lt;/h3&gt;

&lt;p&gt;Our company has 10 angular projects that are actively developed and share a lot of code, but also had 5 legacy projects where there is no budget to bump them to the new Angular versions and so on. There might be a few &lt;a href=&quot;https://vuejs.org/&quot;&gt;Vue.js&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; living there as well. It might be more trouble than it is worth for your organization to manage that complexity within one big workspace. In that case we could have a workspace for the non-legacy angular projects, and that workspace would gladly welcome new projects in the future.&lt;/p&gt;

&lt;h3 id=&quot;scenario-b&quot;&gt;Scenario B&lt;/h3&gt;

&lt;p&gt;Our company sells custom software to different clients. Every client wants its own custom look and feel, which a lot of custom logic, but we don’t want to reinvent the wheel every time.&lt;/p&gt;

&lt;p&gt;In that case, we could create an Nx worspace for every client, and have one common toolkit that contains shared logic. That toolkit would live in its own monorepo and be published as an Angular package.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope we learned something today. How we structure our workspaces is completely up to us, and we should use something that works for us, not just pick whatever you read in some blog article ;-). If this structure doesn’t make sense to you, that’s perfectly fine… And I would love to hear your thoughts about this approach.&lt;/p&gt;

&lt;h2 id=&quot;special-thanks-to&quot;&gt;Special thanks to&lt;/h2&gt;

&lt;p&gt;Thanks to the people that have reviewed the article and gave great input!
I couldn’t have done it without you!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/beeman_nl&quot;&gt;@beeman_nl&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/mrjameshenry&quot;&gt;@MrJamesHenry&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 08 Dec 2018 00:00:00 +0100</pubDate>
        <link>https://blog.brecht.io/opinionated-guidelines-for-large-nx-angular-projects/</link>
        <guid isPermaLink="true">https://blog.brecht.io/opinionated-guidelines-for-large-nx-angular-projects/</guid>
        
        <category>Angular</category>
        
        <category>nx</category>
        
        <category>architecture</category>
        
        
        <category>brechtbilliet</category>
        
      </item>
    
      <item>
        <title>Safe HTTP calls with RxJS</title>
        <description>&lt;p&gt;Hi there, since it’s very busy lately this will probably be my one of my shortest articles ever.
Maybe that’s a good thing, because now you don’t have an excuse not to read it. It’s short, compact
and maybe you will learn a thing or two.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The problem&lt;/h2&gt;

&lt;p&gt;The article is all about making sure our HTTP calls don’t die on bad connections, since strangely enough, &lt;strong&gt;404 responses can kill your application when using RxJS&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Remember that RxJS observables have 3 types of events right?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;next&lt;/code&gt;: passing in a new value into the observable&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;error&lt;/code&gt;: when an error occurs&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;complete&lt;/code&gt;: When the observable is completed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We should not forget that &lt;strong&gt;an Error event will actually stop the observable&lt;/strong&gt;. It will cease to exist.&lt;/p&gt;

&lt;p&gt;You might say: “That’s not that bad, we’ll just create a new one every time we want to fetch data”.&lt;/p&gt;

&lt;p&gt;When you are approaching your application the &lt;em&gt;reactive way&lt;/em&gt;, this scenario might be problematic:
Imagine a typeahead search where we want to retrieve results for every input value. We have an observable of searchterms and we trigger the
HTTP request for every value using a &lt;code&gt;switchMap&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// this observable contains the values
// of what the user is searching for
// over time
const searchTerm$: Observable&amp;lt;string&amp;gt;;

// when the term receives a new value...
// go fetch some data
const results$ = searchTerm$.pipe(
    switchMap(term =&amp;gt; fetchData(term))
)

// subscribe to the observable to start listening
results$.subscribe((response: Result[]) =&amp;gt; {
    console.log(response);
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This all works fine, until an error happens in the observable. This could come from a bad connection, server down-time or anything that went wrong during the HTTP request (500, 404, …) 
If the user is having a bad connection which might result in a &lt;code&gt;404&lt;/code&gt;, the observable will stop and the application will be broken. The user can search for results as much as he or she wants, the HTTP calls will never happen again.&lt;/p&gt;

&lt;h2 id=&quot;catcherror&quot;&gt;catchError&lt;/h2&gt;

&lt;p&gt;We could use the &lt;code&gt;catchError&lt;/code&gt; operator that will basically catch the error for us, and return a brand new observable(containing the error).
That observable will have the error as a value, instead of throwing it again as an error.
That way we could actually show the user a decent message.
This might look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const results$ = searchTerm$.pipe(
    switchMap(term =&amp;gt; 
        fetchData(term).pipe(
            // return an observable with the error inside
            catchError(e =&amp;gt; of(e))
        )
    )
)
results$.subscribe(
    (response: Result[] | HttpErrorResponse) =&amp;gt; {
        if(response instanceof HttpErrorResponse){
            console.log('oh no:(');
            return;
        }
        console.log('do something fancy');
    });
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ps: I’m not trying to say that this is the best idea to catch errors. I’m just showing you around some basics.&lt;/p&gt;

&lt;p&gt;Do note that the &lt;code&gt;catchError&lt;/code&gt; operator is applied to the result observable that &lt;code&gt;fetchData()&lt;/code&gt; returns, and not added as the second operator of the first pipe. 
From the moment an observable receives an error, it will die… That’s why it’s important to catch the error on the inner observable.&lt;/p&gt;

&lt;h2 id=&quot;retrywhen&quot;&gt;retryWhen&lt;/h2&gt;

&lt;p&gt;Ok, great! The application won’t break anymore, but now imagine the following scenario: Our user is sitting in the train and drives through a tunnel. The connection is gone for a few seconds and the user won’t get results.&lt;/p&gt;

&lt;p&gt;We could fix that by telling RxJS to retry a few times&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const results$ = searchTerm$.pipe(
    switchMap(term =&amp;gt; 
        fetchData(term).pipe(
            retryWhen(e$ =&amp;gt; e$.pipe(
                // try again after 2 seconds
                delay(2000),
                // stop trying after 5 times
                take(4)
            )
            // still keep the observable alive if
            // the first 5 times fail
            catchError(e =&amp;gt; of(e))
        )
    )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can find more information about &lt;code&gt;retryWhen&lt;/code&gt;&lt;a href=&quot;https://www.learnrxjs.io/operators/error_handling/retrywhen.html&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;using-the-online-event&quot;&gt;Using the online event&lt;/h2&gt;

&lt;p&gt;Even though this is a good solution, there is room for improvement. A great choice is to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/Online_and_offline_events&quot;&gt;online&lt;/a&gt; event from HTML5 to tell the browser to retry when the user regains internet connection. It’s even shorter than before and it’s super elegant&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const results$ = searchTerm$.pipe(
    switchMap(term =&amp;gt; 
        fetchData(term).pipe(
            retryWhen(() =&amp;gt; fromEvent(window, 'online'))
            // still keep the observable alive if
            // the server would return a different
            // HTTP error
            catchError(e =&amp;gt; of(e))
        )
    )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;RxJS gives us great control over HTTP calls! If we know how error handling works it becomes a breeze to take our HTTP calls to the next level.
This doesn’t only apply to typeahead searches but to every observable where we combine an existing stream with an error-affected one like HTTP. For instance: this can also happen in NgRx effects or with the angular router.&lt;/p&gt;

&lt;p&gt;There, I told you it would be short, I hope you learned something though.&lt;/p&gt;

&lt;p&gt;Also be sure to check this article: &lt;a href=&quot;https://blog.angularindepth.com/power-of-rxjs-when-using-exponential-backoff-a4b8bde276b0&quot;&gt;Power of RxJS when using exponential backoff&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;special-thanks&quot;&gt;Special thanks&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/AmarildoKurtaj&quot;&gt;@AmarildoKurtaj&lt;/a&gt; The last example was based on his idea&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reviewers:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/fmalcher01&quot;&gt;Ferdinand Malcher&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/FabianGosebrink&quot;&gt;Fabian Gosebrink&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/tim_deschryver&quot;&gt;Tim deschryver&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/webdave_de&quot;&gt;David Müllerchen&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/rubenverm&quot;&gt;Ruben Vermeulen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 24 Oct 2018 00:00:00 +0200</pubDate>
        <link>https://blog.brecht.io/safe-http-calls-with-rxjs/</link>
        <guid isPermaLink="true">https://blog.brecht.io/safe-http-calls-with-rxjs/</guid>
        
        <category>RxJS</category>
        
        
        <category>brechtbilliet</category>
        
      </item>
    
      <item>
        <title>Building a safe autocomplete operator in RxJS</title>
        <description>&lt;p&gt;A well-known use case of RxJS is creating a simple autocomplete search in only a few lines of code.
This article is not just about creating our own autocomplete operator, we will create an autocomplete operator that is completely safe (we will cover the perception of safe later in this article).&lt;/p&gt;

&lt;p&gt;When creating a standard autocomplete with RxJS we most likely implement a &lt;code&gt;debounceTime&lt;/code&gt; operator to throttle the text that the user is typing into the autocomplete and we use a &lt;code&gt;switchMap&lt;/code&gt; operator instead of a &lt;code&gt;mergeMap&lt;/code&gt; operator to abort previous calls.&lt;/p&gt;

&lt;p&gt;The implementation of this autocomplete might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const term$ = new BehaviorSubject('');
const results$ = term$
    .pipe(
        // wait until the user stops typing for a second
        debounceTime(1000),
        // higher order observable, abort previous
        // call if still busy
        switchMap(term =&amp;gt; getAutocompleteSuggestions(term))
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The problem&lt;/h2&gt;

&lt;p&gt;When the user stops typing for 1 second, the browser will create a new XHR call. From that moment on, when the user types again and a previous XHR call is still busy, the browser will abort that XHR call to avoid racing conditions, and create a new XHR call. This is due to the &lt;code&gt;switchMap&lt;/code&gt; operator since it will unsubscribe from the previous observable.&lt;/p&gt;

&lt;p&gt;Although that’s great, there is one problem though. What if the user starts typing again when an XHR call is still busy? 
Since we have implemented a &lt;code&gt;debounceTime&lt;/code&gt; operator, the call will not be aborted until one second has passed.
In that period of time new results might be returned and showed to the user, which might not be what we want since &lt;strong&gt;they are not relevant anymore&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;What we want is that the XHR call gets aborted from the moment the user starts typing again, we don’t want to wait for a second.
This sounds like an ideal scenario to write our custom operator.
But, before creating our own operator, let’s just combine some operators to get the job done.&lt;/p&gt;

&lt;p&gt;A possible solution for this problem is using a &lt;code&gt;takeUntil&lt;/code&gt; operator on the observable that will trigger the XHR call.
The &lt;code&gt;takeUntil&lt;/code&gt; operator will complete the observable as soon as it gets a value. We want to complete (and therefore abort) the observable when the user types again. With that knowledge we can write something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const term$ = new BehaviorSubject('');
const results$ = term$
    .pipe(
        debounceTime(1000),
        switchMap(term =&amp;gt; 
            getAutocompleteSuggestions(term)
                .pipe(
                    takeUntil(term$) // this still won't work
                )
            )
        )
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sadly, this does not work yet.&lt;/p&gt;

&lt;p&gt;Our &lt;code&gt;term$&lt;/code&gt; observable is a &lt;code&gt;BehaviorSubject&lt;/code&gt; for two reasons:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;We want to pass an initial value to the subject&lt;/li&gt;
  &lt;li&gt;A &lt;code&gt;BehaviorSubject&lt;/code&gt; is a &lt;code&gt;ReplaySubject(1)&lt;/code&gt; behind the scenes that keeps track of the last value. This is important if we want to subscribe to that observable in a later stage (which is kinda what we do with the &lt;code&gt;takeUntil&lt;/code&gt; operator).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because the &lt;code&gt;term$&lt;/code&gt; observable is keeping track of the last value, the &lt;code&gt;takeUntil&lt;/code&gt; operator will always have a value, resulting in the fact that every XHR call gets aborted immediately. This is not what we want.
We want to skip one value of the &lt;code&gt;term$&lt;/code&gt; observable every time.
We can achieve that with the &lt;code&gt;skip&lt;/code&gt; operator as shown in the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const term$ = new BehaviorSubject('');
const results$ = term$
    .pipe(
        debounceTime(1000),
        switchMap(term =&amp;gt; 
            getAutocompleteSuggestions(term)
                .pipe(
                    takeUntil(
                        //skip 1 value
                        term$.pipe(skip(1))
                    )
                        
                )
            )
        )
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the following scenario works:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;User types ‘l’&lt;/li&gt;
  &lt;li&gt;Application waits for a second&lt;/li&gt;
  &lt;li&gt;Application creates an XHR call&lt;/li&gt;
  &lt;li&gt;User types ‘lu’&lt;/li&gt;
  &lt;li&gt;Even though the XHR call wasn’t finished yet it gets aborted immediately (it doesn’t wait for a second anymore to abort that XHR call)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because of that the user never gets irrelevant data on its screen.&lt;/p&gt;

&lt;h2 id=&quot;extracting-the-logic-into-a-custom-operator&quot;&gt;Extracting the logic into a custom operator&lt;/h2&gt;

&lt;p&gt;We don’t want to write this logic every time, so let’s extract this logic into a custom written operator.&lt;/p&gt;

&lt;p&gt;Turns out that creating custom operators is super easy. An operator is just a function that returns a function that gets the source observable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const autocomplete = (/* additional parameters */) =&amp;gt; 
    (source$) =&amp;gt; source$.pipe(/* do stuff */ )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can pass the &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;selector&lt;/code&gt; function as parameters and use the operators we have written to create our own custom operator.
The operator looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const autocomplete = (time, selector) =&amp;gt; (source$) =&amp;gt;
  source$.pipe(
    debounceTime(time),
    switchMap((...args: any[]) =&amp;gt; selector(...args)
        .pipe(
            takeUntil(
                source$
                    .pipe(
                        skip(1)
                    )
            )
        )
    )
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using our operator is super easy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const term$ = new BehaviorSubject('');
const results$ = term$
    .pipe(
        autocomplete(1000, term =&amp;gt; getAutocompleteSuggestions(term))
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can find the sourcecode on stackblitz.&lt;/p&gt;
&lt;iframe src=&quot;https://stackblitz.com/edit/safe-switchmap?embed=1&amp;amp;file=src/app/app.component.ts&quot; style=&quot;width: 100%; height: 500px&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The combination of &lt;code&gt;debounceTime&lt;/code&gt; and &lt;code&gt;switchMap&lt;/code&gt; don’t always cover everything. Showing irrelevant data to our users might not be what we want and creating our own operators is super easy! I hope you enjoyed the article.&lt;/p&gt;

&lt;h2 id=&quot;special-thanks&quot;&gt;Special thanks&lt;/h2&gt;

&lt;p&gt;A special thanks for the awesome reviewers:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nicholas Jamieson &lt;a href=&quot;https://twitter.com/ncjamieson&quot;&gt;@ncjamieson&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Philippe Martin &lt;a href=&quot;https://twitter.com/feloy2&quot;&gt;@feloy2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Jan-Niklas Wortmann &lt;a href=&quot;https://twitter.com/niklas_wortmann&quot;&gt;@niklas_wortmann&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Maarten Tibau &lt;a href=&quot;https://twitter.com/maartentibau&quot;&gt;@maartentibau&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Kwinten Pisman &lt;a href=&quot;https://twitter.com/kwintenp&quot;&gt;@kwintenp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 13 Jul 2018 00:00:00 +0200</pubDate>
        <link>https://blog.brecht.io/building-a-safe-autocomplete-operator-with-rxjs/</link>
        <guid isPermaLink="true">https://blog.brecht.io/building-a-safe-autocomplete-operator-with-rxjs/</guid>
        
        <category>RxJS</category>
        
        
      </item>
    
      <item>
        <title>Thinking reactive with the SIP principle</title>
        <description>&lt;p&gt;A few months back we released &lt;a href=&quot;https://blog.strongbrew.io/rxjs-best-practices-in-angular/&quot;&gt;RxJS best practices in Angular&lt;/a&gt; and a while before that &lt;a href=&quot;https://blog.strongbrew.io/thinking-reactively-in-angular-and-rxjs/&quot;&gt;Thinking reactively in Angular and RxJS&lt;/a&gt;. 
Both of these articles are focussing on “trying to make the mind switch towards reactive programming”.&lt;/p&gt;

&lt;p&gt;However, sometimes we like to have structured opinionated ways of tackling problems, especially when things become complex. We like a roadmap of some kind, something to fall back on, something to guide us through these complex reactive scenarios.&lt;/p&gt;

&lt;p&gt;While writing RxJS code for small pragmatic solutions can be super easy, it might become complex when combining multiple streams or doing other advanced stuff.&lt;/p&gt;

&lt;p&gt;We as StrongBrew are huge fans of reactive programming and we use our reactive mindset in Angular on a daily basis.
In this article we will learn a principle that helps us to tackle very complex RxJS situations in an opinionated structured way.&lt;/p&gt;

&lt;p&gt;The code of this article is written with &lt;a href=&quot;https://angular.io&quot;&gt;Angular&lt;/a&gt; but the concepts can be used with every framework.&lt;/p&gt;

&lt;h2 id=&quot;the-situation&quot;&gt;The situation&lt;/h2&gt;

&lt;p&gt;We are going to build an application to search for starships in the &lt;a href=&quot;https://swapi.co&quot;&gt;swapi api&lt;/a&gt;. The application counts a few features:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It has to load data on page load&lt;/li&gt;
  &lt;li&gt;The user can search for starships by entering text in the searchbox&lt;/li&gt;
  &lt;li&gt;The user can load starships by a chosen model&lt;/li&gt;
  &lt;li&gt;The user can load starships by a random model&lt;/li&gt;
  &lt;li&gt;There is a loading indicator that needs to be shown when the data is being loaded&lt;/li&gt;
  &lt;li&gt;Previous XHR calls should be canceled to avoid race conditions&lt;/li&gt;
  &lt;li&gt;We want to filter the results by the number of passengers allowed on the ship. &lt;strong&gt;Note: This is a clientside filter&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As we can see, there is quite a lot of asynchronous logic going on here, and if we would implement this in an imperative way, it would be pretty hard to keep it simple. However, the application can easily be written with the use of RxJS. In this application we don’t want to think in actions anymore, we want to think in streams of data. &lt;strong&gt;Everything is a stream!&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-sip-principle&quot;&gt;The SIP principle&lt;/h2&gt;
&lt;p&gt;With StrongBrew, we came up with a simple principle of handling this reactive mindset. We call it the &lt;strong&gt;SIP principle&lt;/strong&gt;.
The SIP principle stands for the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;S: Source streams&lt;/li&gt;
  &lt;li&gt;I: Intermediate streams&lt;/li&gt;
  &lt;li&gt;P: Presentation streams&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;source-streams&quot;&gt;Source streams&lt;/h3&gt;

&lt;p&gt;These streams will contain all the user interaction. They are generally bound to the outputs of our dumb components. A source stream could also contain real-time data, but we won’t cover that part in this article.
Let’s have a look at our application and look for the source streams there:
(the left column pretty much contains all the user interaction)
&lt;img src=&quot;/assets/images/posts/sip-principle/source-streams.png&quot; alt=&quot;Source streams&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After executing the first step of the SIP principle we have found 4 source streams.
&lt;code&gt;searchTerm$&lt;/code&gt;, &lt;code&gt;selectedModel$&lt;/code&gt;, &lt;code&gt;randomModel$&lt;/code&gt; and &lt;code&gt;numberOfPassengers$&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What’s important to note here is that we named these streams as &lt;strong&gt;streams of data&lt;/strong&gt; rather than naming them as streams of actions. We want to stop thinking in actions and start thinking in streams of data, remember? That’s why we didn’t name the first stream &lt;code&gt;search$&lt;/code&gt; (which would be an action), we rather named it &lt;code&gt;searchTerm$&lt;/code&gt; so we know it contains a search term.&lt;/p&gt;

&lt;p&gt;Source streams are &lt;strong&gt;mostly subjects&lt;/strong&gt; or streams that come from the framework, e.g. a routing params stream.&lt;/p&gt;

&lt;p&gt;In our application the source streams will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;searchTerm$ = new ReplaySubject&amp;lt;string&amp;gt;(1);
selectedModel$ = new ReplaySubject&amp;lt;string&amp;gt;(1);
randomModel$ = new ReplaySubject&amp;lt;string&amp;gt;(1);
// needs an initial value
numberOfPassengers$ = new BehaviorSubject(1000000); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These subjects will be populated by the outputs as shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;sidebar 
    (search)=&quot;searchTerm$.next($event)&quot;
    (selectModel)=&quot;selectedModel$.next($event)&quot;
    (randomModel)=&quot;randomModel$.next($event)&quot;
    (changeNumberOfPassengers)=&quot;numberOfPassengers$.next($event)&quot;
&amp;gt;
&amp;lt;/sidebar&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;presentation-streams&quot;&gt;Presentation streams&lt;/h3&gt;

&lt;p&gt;After finding the source streams we need to find the presentation streams.
These are the streams that our template needs to render properly. These are quite easy to find. We just have to look at the template and see which inputs our components expect. We can have a look at our template. (The outputs are stripped for readability purposes).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;sidebar class=&quot;sidebar&quot; 
    [models]=&quot;fixedModels&quot; 
    [numberOfPassengers]=&quot;&quot;
  &amp;gt;
  &amp;lt;/sidebar&amp;gt;
  &amp;lt;div class=&quot;main&quot;&amp;gt;
    &amp;lt;starship-list 
        [starships]=&quot;&quot;
        [loading]=&quot;&quot;&amp;gt;
    &amp;lt;/starship-list&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can instantly see that we need 3 presentation streams:
We need the number of passengers, the starships that need to be shown and whether the application is loading or not. Let’s fill in the blanks, shall we?!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;sidebar class=&quot;sidebar&quot; 
    [models]=&quot;fixedModels&quot; 
    [numberOfPassengers]=&quot;numberOfPassengers$|async&quot;
  &amp;gt;
  &amp;lt;/sidebar&amp;gt;
  &amp;lt;div class=&quot;main&quot;&amp;gt;
    &amp;lt;starship-list 
        [starships]=&quot;filteredResults$|async&quot;
        [loading]=&quot;loading$|async&quot;&amp;gt;
    &amp;lt;/starship-list&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So after step 2 we have found the following presentation streams: &lt;code&gt;numberOfPassengers$&lt;/code&gt;, &lt;code&gt;filteredResults$&lt;/code&gt; and &lt;code&gt;loading$&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;starting-with-the-sip-diagram&quot;&gt;Starting with the SIP diagram&lt;/h3&gt;

&lt;p&gt;Let’s visualize these streams by creating a SIP diagram:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/sip-principle/sp.png&quot; alt=&quot;Source streams, presentation streams&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The goal is to calculate the presentation streams, based on the source streams. There are 2 presentation streams that we need to calculate: &lt;code&gt;filteredResults$&lt;/code&gt; and &lt;code&gt;loading$&lt;/code&gt;. We don’t need to calculate &lt;code&gt;numberOfPassengers$&lt;/code&gt; since it’s the same stream as the source stream.&lt;/p&gt;

&lt;p&gt;Let’s start with the &lt;code&gt;filteredResults$&lt;/code&gt;. The &lt;code&gt;filteredResults$&lt;/code&gt; is dependent on &lt;code&gt;searchTerm$&lt;/code&gt;, &lt;code&gt;selectedModel$&lt;/code&gt;, &lt;code&gt;randomModel$&lt;/code&gt; and &lt;code&gt;numberOfPassengers$&lt;/code&gt;. To make this calculation easier we can use intermediate streams.&lt;/p&gt;

&lt;h3 id=&quot;intermediate-streams&quot;&gt;Intermediate streams&lt;/h3&gt;

&lt;p&gt;Intermediate streams are streams that are used to make the bridge between the source streams and presentation streams easier.
Let’s create a &lt;code&gt;query$&lt;/code&gt; stream and a &lt;code&gt;results$&lt;/code&gt; stream to make the calculation easier.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/sip-principle/sip1.png&quot; alt=&quot;SIP 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We will use custom marble diagrams to visualize the different parts of the SIP diagram throughout this article.&lt;/p&gt;

&lt;h4 id=&quot;calculating-the-query&quot;&gt;Calculating the query$&lt;/h4&gt;

&lt;p&gt;The first intermediate stream that we have to create is the &lt;code&gt;query$&lt;/code&gt; which is simply a merge from the &lt;code&gt;searchTerm$&lt;/code&gt;, &lt;code&gt;selectedModel$&lt;/code&gt; and &lt;code&gt;randomModel$&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/sip-principle/query.png&quot; alt=&quot;Query&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see these 3 streams are being merged into one new &lt;code&gt;query$&lt;/code&gt;. We don’t have to worry about when a user searches or selects a model, or even requests a random model. We only care about that simple stream of data, the &lt;code&gt;query$&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;calculating-the-results&quot;&gt;Calculating the results$&lt;/h4&gt;

&lt;p&gt;Every time the &lt;code&gt;query$&lt;/code&gt; gets a new value we want to fetch data from the API. For that we will use the &lt;code&gt;switchMap&lt;/code&gt; operator.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/sip-principle/results.png&quot; alt=&quot;Results&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;calculating-filteredresults&quot;&gt;Calculating filteredResults$&lt;/h4&gt;

&lt;p&gt;We are ready to finish up the &lt;code&gt;filteredResults$&lt;/code&gt; stream.
If we look back at the previous SIP diagram we can see that we can create that stream by combining the &lt;code&gt;results$&lt;/code&gt; and the &lt;code&gt;numberOfPassengers$&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/sip-principle/filteredResults.png&quot; alt=&quot;Filtered results&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;the-loading&quot;&gt;The loading$&lt;/h4&gt;

&lt;p&gt;The next presentation stream that we want to create is called the &lt;code&gt;loading$&lt;/code&gt;. Let’s update the SIP diagram accordingly. The &lt;code&gt;loading$&lt;/code&gt; is based on the &lt;code&gt;query$&lt;/code&gt; and the &lt;code&gt;results$&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/sip-principle/sip2.png&quot; alt=&quot;sip 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Every time the &lt;code&gt;query$&lt;/code&gt; gets a new value the &lt;code&gt;loading$&lt;/code&gt; should get the value &lt;code&gt;true&lt;/code&gt;. Everytime the &lt;code&gt;result$&lt;/code&gt; gets a new value the &lt;code&gt;loading$&lt;/code&gt; should get the value &lt;code&gt;false&lt;/code&gt;.
So if we map every value of the &lt;code&gt;query$&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; and if we map every value of the &lt;code&gt;results$&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, and merge those 2, we have created our &lt;code&gt;loading$&lt;/code&gt; stream.&lt;/p&gt;

&lt;p&gt;Let’s create one last marble diagram for that.
&lt;img src=&quot;/assets/images/posts/sip-principle/loading.png&quot; alt=&quot;Loading&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;what-do-we-need-to-share&quot;&gt;What do we need to share?&lt;/h3&gt;

&lt;p&gt;We have came a long way, we have created the complete SIP diagram. We have visualized all the streams by creating marble diagrams, but if we look closely at the SIP diagram we might notice a problem.
There are 2 arrows leaving the &lt;code&gt;query$&lt;/code&gt; and 2 arrows leaving the &lt;code&gt;results$&lt;/code&gt;. Every arrow stands for a subscription on the observable where the arrow starts.
When working with cold observables, the producer function for that observable is executed every time we subscribe. Since &lt;code&gt;query$&lt;/code&gt; is a hot stream, it doesn’t really matter, but &lt;code&gt;results$&lt;/code&gt; will trigger an HTTP call every time it gets subscribed to. In short: the subscription on &lt;code&gt;loading$&lt;/code&gt; and &lt;code&gt;filteredResults$&lt;/code&gt; will trigger a subscription on &lt;code&gt;results$&lt;/code&gt; twice. The SIP diagram show us which subscriptions need to be shared.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/sip-principle/sip3.png&quot; alt=&quot;sip3&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;check-it-out&quot;&gt;Check it out&lt;/h2&gt;

&lt;p&gt;The SIP diagram is complete now and we can start coding. Since this article is really about the SIP principle I won’t explain the code in detail. However, you can find the complete code in the StackBlitz below.&lt;/p&gt;
&lt;iframe src=&quot;https://stackblitz.com/edit/sip-principle?embed=1&amp;amp;file=app/app.component.ts&quot; style=&quot;width: 100%; height: 500px&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Before starting with implementing complex RxJS screens. Take a whiteboard and draw the flow first. The SIP principle that we created works for us but isn’t the only way to go of course.&lt;/p&gt;

&lt;p&gt;If you check the code inside the StackBlitz, you might be surprised about the amount of lines of code that we need to create this application. We have only a few lines of real logic, and we have covered most corner cases by thinking reactive.&lt;/p&gt;

&lt;p&gt;Because of the use of the &lt;code&gt;async&lt;/code&gt; pipe we don’t need to unsubscribe from any stream manually since the &lt;code&gt;async&lt;/code&gt; pipe does that for us.&lt;/p&gt;

&lt;h2 id=&quot;special-thanks&quot;&gt;Special thanks&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/jvandemo&quot;&gt;Jurgen van de Moere&lt;/a&gt; for helping us with finding the right acronym.&lt;/p&gt;

&lt;p&gt;And the awesome reviewers:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/manfredsteyer&quot;&gt;Manfred Steyer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/niklas_wortmann&quot;&gt;Jan-Niklas Wortmann&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/tim_deschryver&quot;&gt;Tim Deschryver&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/webdave_de&quot;&gt;David Müllerchen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 30 Jun 2018 00:00:00 +0200</pubDate>
        <link>https://blog.brecht.io/the-sip-principle/</link>
        <guid isPermaLink="true">https://blog.brecht.io/the-sip-principle/</guid>
        
        <category>RxJS</category>
        
        
      </item>
    
      <item>
        <title>Redux (@ngrx/store) best practices</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/ngrx/platform/blob/master/docs/store/README.md&quot;&gt;@ngrx/store&lt;/a&gt; is a library that tries to solve the problems of state management through the principles of &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt;. The difference between Redux and @ngrx/store is that @ngrx/store is written specifically for &lt;a href=&quot;https://angular.io&quot;&gt;Angular&lt;/a&gt; and it embraces the use of Observables from &lt;a href=&quot;http://reactivex.io/rxjs/&quot;&gt;RxJS&lt;/a&gt;.
The combination of redux principles and RxJS can be very powerful when it comes to writing reactive applications.
Since a lot of Angular projects use @ngrx/store, it might be a good idea to write down some best-practices.&lt;/p&gt;

&lt;p&gt;Note: The best-practices and opinions described in this article are strictly personal. Best practices are almost always a matter of opinion. Nevertheless, we (StrongBrew) are using these best practices at all our customers on a daily basis and they certainly work for us.   From now on @ngrx/store will be reffered to as Redux in this article.&lt;/p&gt;

&lt;h2 id=&quot;to-redux-or-not-to-redux&quot;&gt;To Redux or not to Redux?&lt;/h2&gt;

&lt;p&gt;The first question that we might want to ask ourselves is do we really need Redux in our application.
It is a best practice to only use it when your application demands it.
&lt;a href=&quot;https://blog.strongbrew.io/do-we-really-need-redux&quot;&gt;This article&lt;/a&gt; tackles this question separately.&lt;/p&gt;

&lt;h2 id=&quot;basic-best-practices&quot;&gt;Basic best practices&lt;/h2&gt;

&lt;p&gt;While the following list might be common sense for an experienced Redux developer, let’s sum those up as a refreshment for the sake of completeness.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Our application can only count one store, otherwise it would become too complex&lt;/li&gt;
  &lt;li&gt;Reducers have to be pure, this is a principle from functional programming which makes functions predictable and avoids side effects&lt;/li&gt;
  &lt;li&gt;Immutable datastructures are very important to optimise change detection cycles and avoid unexpected behavior, therefore reducers should handle data in an immutable manner&lt;/li&gt;
  &lt;li&gt;Reducers always have to return a value! So don’t forget to implement the default case of the switch statement to return the original state&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dont-add-models-to-the-store&quot;&gt;Don’t add models to the store&lt;/h2&gt;

&lt;p&gt;A model can be seen as a javascript object which has functionality, like the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;class User{
    constructor(private firstName: string, private lastName:string){
    }

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`; 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While the Redux package written by Dan Abramov forbids sending these prototyped objects as a payload, @ngrx/store does not forbid it yet.
However, it is a bad practice because it adds a lot of complexity to the store and chances are big that the models will get broken because of the immutable way of handling data. Check this example for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const user = new User('Brecht', 'Billiet');
console.log(user.fullName); // Brecht Billiet
const updatedUser = {...user, lastName: 'Doe'};
console.log(updatedUser.fullName); // undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we have updated the user in an immutable way, it has created a new reference and therefore all its functionality has been lost.
This is exactly what our reducers will do with the data that flows into them. So always send plain objects when it comes to sending payloads in the actions.&lt;/p&gt;

&lt;p&gt;Another approach for models is using Interfaces. Interfaces are great because are only interpreted in compile time, doesn’t use memory in runtime and are very expressive. If your model doesn’t need to be computed (like &lt;code&gt;get fullName()&lt;/code&gt; in the previous example), then is advisable to use Interfaces instead.&lt;/p&gt;

&lt;p&gt;Using Interfaces allows us to get advantage of some TypeScript features like &lt;code&gt;Pick&amp;lt;T&amp;gt;&lt;/code&gt;. With &lt;code&gt;Pick&amp;lt;T&amp;gt;&lt;/code&gt; we can create Types from Interfaces, which is very handy in some situations, like creating a model and a record with fewer properties:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;export interface User {
    id: number;
    name: string;
    middleName: string;
    lastName: string;
    fullName: string;
    address: string;
    city: string;
    state: string;
    zip: string;
}

export type UserRecord = Pick&amp;lt;User, 'id' | 'fullName'&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the endpoint to get a list of users is returning a partial object instead of the full object then we can create a new Type instead of two Classes or Interfaces. This is a cleaner approach and easier to maintain if your models are prepared for your UI.&lt;/p&gt;

&lt;h2 id=&quot;what-do-we-put-in-the-store&quot;&gt;What do we put in the store?&lt;/h2&gt;

&lt;p&gt;We shouldn’t put things in the store just because we can. We have to think about what state needs to be in there and why.
State that is being shared between components can sometimes be kept in the parent component for instance. We call that inner state:
The component keeps its own state, the component itself is responsible for that. If that component state does not affect anything from the application state, it does not need to be on the application state or touch redux.&lt;/p&gt;

&lt;p&gt;However, when state needs to be shared between different root components (rendered inside a router-outlet) we might want to keep that state in the store.&lt;/p&gt;

&lt;p&gt;When we need to remember a value when navigating through the application we could put that in the store as well. An example here could be: Remembering if a sidebar was collapsed or not, so when we navigate back to the page with the sidebar, it would still be collapsed.&lt;/p&gt;

&lt;p&gt;Complex state is something that we might want to put in the store as well, since Redux can handle complex state management in an elegant way.
The general rule of thumb here could be, &lt;strong&gt;Only keep shared state, values that we want to remember and complex state in the store&lt;/strong&gt;. Don’t add state in the store if we don’t need to, it would result in unneeded boilerplate and complexity.&lt;/p&gt;

&lt;p&gt;That being said, there are 2 more reasons where we might want to add extra state into the store:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;When we want to make our application real-time. Check out &lt;a href=&quot;https://blog.strongbrew.io/How-we-made-our-app-real-time-in-6-lines-of-code/&quot;&gt;How we made our app real time in 6 lines of code&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;When we want to do optimistic updates. Check out &lt;a href=&quot;https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/&quot;&gt;Cancellable optimistic updates in Angular2 and Redux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dont-forget-about-router-params&quot;&gt;Don’t forget about router params&lt;/h2&gt;

&lt;p&gt;A common mistake is putting things inside the store that could easily be added in the url.
The benefit of keeping state in the url is:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We can use the browser navigation buttons&lt;/li&gt;
  &lt;li&gt;We can bookmark the url&lt;/li&gt;
  &lt;li&gt;We can share that url with other people&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If we can put simple things into the url, we should at least consider it.&lt;/p&gt;

&lt;h2 id=&quot;avoid-huge-lists&quot;&gt;Avoid HUGE lists&lt;/h2&gt;

&lt;p&gt;Redux can not be seen as a local in-memory database, so we can’t put all our data into the store for performance reasons.
Redux can be seen as an abstraction of state and data that our application needs at a certain time.&lt;/p&gt;

&lt;p&gt;For instance if we have a list of 10000 users, we don’t want to put them all in the store. What we could do is keep track of a list of 500 users in the store, which the user can see at that specific time, and load more users on the background and update that buffered list.&lt;/p&gt;

&lt;h2 id=&quot;designing-the-state&quot;&gt;Designing the state&lt;/h2&gt;

&lt;p&gt;Designing the state of our application is an important step, and we recommend to draw that state on a whiteboard first. The most important rule here is: &lt;strong&gt;Keep the state as flat as possible&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;One of the most common bad practices is deep-nesting the state into something that becomes rather complex:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typscript&quot;&gt;
// this is an example of how not to design state
export interface ApplicationState {
    moduleA: {
        data: {
            foo: {
                bar: {
                    users: User[],
                    cars: Car[]
                }
            }
        }
    }
}  

// keeping it flat makes the application way easier
export interface ApplicationState {
    users: User[],
    cars: Car[]
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I’m not saying you cannot nest state, I am saying we have to be very careful when we do. The general rule of thumb here is: &lt;strong&gt;keep the state as flat as possible&lt;/strong&gt;
If we want to compose state in @ngrx/store we can work with feature module reducers and lazy load them as we can see in &lt;a href=&quot;https://github.com/ngrx/platform/blob/master/docs/store/api.md#feature-module-state-composition&quot;&gt;Feature Module State Composition&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;make-everything-readonly&quot;&gt;Make everything readonly&lt;/h2&gt;

&lt;p&gt;We already covered the reason why we need to work immutable, but how can we enforce this?
Typescript comes with a readonly keyword which we can use to make a property readonly&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;type User = {
    readonly firstName: string;
    readonly lastName: string;
}

const user: User = {firstName: 'Brecht', lastName: 'Billiet'};
user.lastName = 'Doe';//cannot assign to 'lastName' 
// because it is a constant of read-only property
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would certainly make sure we aren’t updating properties in our reducers by accident. It does suck that we have to write readonly for every property.
The cool thing is that typescript offers us something called “advanced types” where we can do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// By using the Readonly&amp;lt;&amp;gt; advanced types all the properties inside the type
// are readonly by default
type User = Readonly&amp;lt;{
    firstName: string;
    lastName: string;
}&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;action-design&quot;&gt;Action design&lt;/h2&gt;

&lt;h3 id=&quot;actiontypes&quot;&gt;Actiontypes&lt;/h3&gt;

&lt;p&gt;An action type should be a string that explains what the action should change in the store. Keep these strings consistent. Don’t make the actiontypes too long, keep them short and clear.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// This is bad
const DATA_USERS_SET_USER_ADDRESS = 'DATA_USERS_SET_USER_ADDRESS';

// This is better
const SET_USER_ADDRESS = 'SET_USER_ADDRESS';

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another cool idea might be to suffix the action with square brackets and put the whole thing into an action object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;
// Easy to read/debug
const UserActions = {
  SET_ADDRESS: '[USER] ADDRESS'
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the state managment would become very large we could prefix the action, but let’s keep it simple and small as long as we can.&lt;/p&gt;

&lt;h3 id=&quot;action-creator-classes&quot;&gt;Action creator classes&lt;/h3&gt;

&lt;p&gt;When we use plain action types and payloads it becomes quite painful to remember all the action type names and all the payloads that belong to them. This example for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const user_id = '1234', address = {whatevz};
this.store.dispatch(
    {
        type: 'SET_USER_ADDRESS', 
        payload: {user_id, address}
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s pretty nasty if we want remember all that stuff, so let’s create action creator classes for these. What if we could do this?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const user_id = '1234', address = {whatevz};
this.store.dispatch(new SetUserAddressAction(user_id, address));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s just became way easier to use and we don’t have to remember the payload of the action.&lt;/p&gt;

&lt;p&gt;If we wanted to implement the actioncreator class for this action it would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;class SetUserAddressAction implements Action {
    type = SET_USER_ADDRESS;
    payload: {user_id: string, address: Address};
    constructor(user_id: string, address: Address){
        this.payload = {user_id, address};
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;payload-design&quot;&gt;Payload design&lt;/h3&gt;

&lt;p&gt;When the action would only have one property for the payload we might be encouraged to use the payload directly instead of creating a property in it. However that would lead to inconsistency, so it might be better to always use subproperties&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// This is bad (inconsistent with the rest of the actions)
class UpdateUserAction implements Action {
    type = UPDATE_USER;
    payload: User;
    constructor(user: User){
        this.payload = user;
    }
}
// This is better
class UpdateUserAction implements Action{
    type = UPDATE_USER;
    payload: {user: User};
    constructor(user: User){
        this.payload = {user};
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;type-safety&quot;&gt;Type Safety&lt;/h3&gt;

&lt;p&gt;Type Safety is a huge win when using Redux with typescript, it requires a bit of boilerplate but it makes developing reducers feel like a walk in the park. It makes sure that our applications won’t compile if they have type errors and it gives us great autocompletion inside our reducers.
Therefore I would definitely consider it a must. Since &lt;a href=&quot;https://twitter.com/KwintenP&quot;&gt;Kwinten Pisman&lt;/a&gt; already wrote an &lt;a href=&quot;https://blog.strongbrew.io/type-safe-actions-in-reducers/&quot;&gt;awesome article&lt;/a&gt; about this we won’t go in to much detail here.&lt;/p&gt;

&lt;h2 id=&quot;reducer-design&quot;&gt;Reducer design&lt;/h2&gt;

&lt;h3 id=&quot;destructuring-the-payload&quot;&gt;Destructuring the payload&lt;/h3&gt;

&lt;p&gt;If we want to make the reducer code more readable and shorter we could use javascript destructuring for that.
This might be personal preference, but it sure as hell makes our reducers easier to read. Take this example for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;function usersReducer
  (state: User[], action: UserActions): User []{
    switch(action.type) {
      case 'SET_USER_ADDRESS':
        return state.map(v =&amp;gt; 
          v.id === action.payload.user_id ? 
          {...user, address: action.payload.address} : 
          v
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;action.payload.&lt;/code&gt;code comes back a few times, resulting in longer codelines.
The following piece of code might be more readable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;function usersReducer
  (state: User[], action: UserActions): User []{
    switch(action.type) {
      case 'SET_USER_ADDRESS': {
        const {user_id, address} = action.payload;
        return state.map(v =&amp;gt; 
          v.id === user_id ? 
          {...user, address} : 
          v
        )
      }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see have have used destructuring to extract the properties of the payload into variables.
Cleaner right? Let’s imagine that our actions has 5 or even more properties on their payloads. In that case this would definitely help.
Something to note here is that the case implementation is wrapped inside a block statement. This is important because our reducer can have the same payload properties for different actions.&lt;/p&gt;

&lt;p&gt;This means that &lt;code&gt;user_id&lt;/code&gt; and &lt;code&gt;address&lt;/code&gt; won’t be available in the other case statements, which is exactly what we want.&lt;/p&gt;

&lt;h3 id=&quot;dont-write-business-logic-inside-our-reducers&quot;&gt;Don’t write business logic inside our reducers&lt;/h3&gt;

&lt;p&gt;Reducers should not contain business logic, they are used to handle the state in an immutable fashion. We won’t write business logic inside reducers because:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It would become very complex&lt;/li&gt;
  &lt;li&gt;Business logic has nothing to do with state management&lt;/li&gt;
  &lt;li&gt;We have services for that&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;child-reducers&quot;&gt;Child reducers&lt;/h3&gt;

&lt;p&gt;When reducers need to update a piece of state a few levels down in the tree it can become complex in no-time. Take this example for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;type User = {
    id: string;
    contracts: Contract[];
}
type Contract = {
    id: string;
    assignees: Assignee[];
}
type ApplicationState = {
    users: User[];
}   
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we would put all the logic to add an assignee to a specific contract of a specific user, the code would be hard to read. Checkout the following piece of code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// This is bad
function usersReducer
  (state: User[], action: UserActions): User []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const {user_id, contract_id, assignee} = action.payload;
      return state.map(v =&amp;gt; 
        v.id === user_id ? 
        {
          ...user, 
          contracts: user.contracts.map(contract =&amp;gt; 
            contract.id === contract_id ?
            {
              ...contract, 
              assignees: [...contract.assignees, assignee]
            } : 
            contract
          )
        } : 
        v
      )
    }
    default:
      return state;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When reducers become complex it might be a good idea to split the reducer up into child reducers. Check the refactored version of the previous example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// This is better
function usersReducer
  (state: User[], action: UserActions): User []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const {user_id, contract_id, assignee} = action.payload;
      return state.map(v =&amp;gt; 
        v.id === user_id ? 
        {
          ...user, 
          contracts: contractsReducer(contracts, action.payload)
        } : 
        v
      )
    }
    default:
      return state;
  }
}

function contractsReducer
  (state: Contract[], action: UserActions): Contract []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const { contract_id, assignee} = action.payload;
      return state.map(v =&amp;gt; 
        v.id === contract_id ? 
        {
          ...contract, 
          assignees: [...assignees, assignee]
        } : 
        v
      )
    }
    default:
      return state;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see, we have extracted the handling of contracts into its own reducer, which follows the exact same principles of a regular reducer.&lt;/p&gt;

&lt;p&gt;The example just became a lot easier to read and way more maintainable. When traversing complex data structures, reducer nesting can be a really elegant way of managing state.&lt;/p&gt;

&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;

&lt;p&gt;Since reducers are pure functions, unit testing them is very easy.
We won’t need to mock out any dependencies and we only have to test the value that the reducer returns.&lt;/p&gt;

&lt;p&gt;We can also use &lt;a href=&quot;https://www.npmjs.com/package/deep-freeze&quot;&gt;deepfreeze&lt;/a&gt; to freeze the state that when the reducer accidently mutates data, the tests will throw an error. Deepfreeze is nothing more than a recursive &lt;code&gt;Object.freeze&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;describe('reducer: usersReducer', () =&amp;gt; {
  describe('case UPDATE_USER', () =&amp;gt; {
    it('should return a new instance with the correct state', 
    () =&amp;gt; {
      const initialState = [new User('1'), new User('2')];
      // deepfreeze makes sure the reducer 
      // doesn't mutate anything by accident
      deepfreeze(initialState); 
      const user = new User('2');
      const action = new UpdateUserAction(user);
      const newState = usersReducer(initialState, action);
      // check if the result of the array is a new ref
      expect(newState).not.toBe(initialState); 
      // check if the result of the user is a new ref
      expect(newState[1]).not.toBe(initialState[1]);
      // check if the user got updated automatically
      expect(newState[1]).toEqual(user);
    });
  });
});
  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note: Don’t forget to test the default action&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;decoupling-redux-from-the-presentation-layer&quot;&gt;Decoupling redux from the presentation layer&lt;/h2&gt;

&lt;p&gt;Having the store injected everywhere in our application is not a good idea. We want to create an Angular, Vue or React application. Not a Redux application.&lt;/p&gt;

&lt;p&gt;Therefore we could consider the following as best practices:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Components don’t need to know we are using Redux, don’t inject the store in them.&lt;/li&gt;
  &lt;li&gt;Services generally don’t need to know we are using Redux, don’t inject the store in them.&lt;/li&gt;
  &lt;li&gt;We want to be able to refactor Redux away from our application without to much effort&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Therefore we want to have some kind of abstraction layer between the presentation layer and the state management layer.&lt;/p&gt;

&lt;p&gt;How to abstract away the statemanagement layer can be read in the following two articles: &lt;a href=&quot;https://blog.strongbrew.io/A-scalable-angular2-architecture/&quot;&gt;A scalable angular architecture&lt;/a&gt; and &lt;a href=&quot;https://blog.strongbrew.io/A-scalable-angular-architecture-part2/&quot;&gt;A scalable angular architecture part 2&lt;/a&gt;.
This is an architecture that we are using at our customers that really works for us.&lt;/p&gt;

&lt;h2 id=&quot;redux-as-a-messaging-bus-vs-redux-as-a-state-management-layer&quot;&gt;Redux as a messaging bus VS redux as a state management layer&lt;/h2&gt;

&lt;p&gt;This might be a personal preference, but I like to use Redux as a pure state management layer. Yes, there are tools like @ngrx/effects where
we can send actions to our application and those actions won’t just perform state management but will do XHR calls among other things.&lt;/p&gt;

&lt;p&gt;The nice thing about this approach is that we use some kind of messaging bus. However, I mostly like to keep it simple and abstract Redux away as much as possible. Therefore I don’t use @ngrx/effects and only use Redux to update pieces of state and consume theses pieces. Some part of me believes that Redux shouldn’t be used to perform backend calls nor decide when to optimistically update. I usually tackle optimistic updates &lt;a href=&quot;https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/&quot;&gt;this way&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That being said, I wouldn’t call my approach a best practice, but it is a best practice to really think about which way we want it.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We learned a lot! Once again, the best practices explained in this article are based on personal experiences and projects we have worked on. These are practices that work for us. They are not meant to be seen as the only way of doing things.&lt;/p&gt;

&lt;h2 id=&quot;special-thanks&quot;&gt;Special thanks&lt;/h2&gt;

&lt;p&gt;A very warm and much appreciated special thanks to the following people:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/ncjamieson&quot;&gt;Nicholas Jamieson&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/elecash&quot;&gt;Raúl Jiménez&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/FabianGosebrink&quot;&gt;Fabian Gosebrink&lt;/a&gt;: Thank you all so much for reviewing and pointing out some awesome ideas&lt;/p&gt;

&lt;p&gt;Your input makes blogging worth while!&lt;/p&gt;
</description>
        <pubDate>Fri, 27 Apr 2018 00:00:00 +0200</pubDate>
        <link>https://blog.brecht.io/Redux-best-practices/</link>
        <guid isPermaLink="true">https://blog.brecht.io/Redux-best-practices/</guid>
        
        <category>Redux</category>
        
        <category>@ngrx</category>
        
        <category>Angular</category>
        
        
        <category>brechtbilliet</category>
        
      </item>
    
      <item>
        <title>Do we really need Redux or @ngrx/store</title>
        <description>&lt;h2 id=&quot;about-this-article&quot;&gt;About this article&lt;/h2&gt;

&lt;p&gt;If you are writing Angular, Vue or React applications, chances are big that you have used or encountered the Redux pattern.
Redux helps us to structure statemanagement in an immutable matter which is great, but in order to use it correctly, we have to write a bunch of boilerplate code.
In this article I would like to tackle the question on when to use Redux and why.
The referred plugins/code samples are written in an Angular context. But the principles explained in this articles work for other frameworks as well. This also means that we are using the &lt;a href=&quot;https://github.com/ngrx/platform/blob/master/docs/store/README.md&quot;&gt;@ngrx/store&lt;/a&gt; package instead of the &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; package&lt;/p&gt;

&lt;h2 id=&quot;to-redux-or-not-to-redux&quot;&gt;To Redux or not to Redux?&lt;/h2&gt;

&lt;p&gt;First of all it’s important to note that Redux solves certain problems for us. If we are not experiencing those problems, then there is a big chance that the Redux pattern
is overkill for our application.&lt;/p&gt;

&lt;p&gt;The first question that we might want to ask ourselves is:
&lt;strong&gt;Does My application have state?&lt;/strong&gt; State can be the value of a pager that we want to remember, or the fact that a sidebar is collapsed or not. State could be a cached set of data coming from our backend, or user information that we need throughout the whole application.
It could be a simple value that we want to remember in memory when we are navigating between pages.&lt;/p&gt;

&lt;p&gt;Let’s sum up some examples where the Redux principle might shine in our applications:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Storing state (like the value of a search filter so it’s still available when the user navigates back to a certain grid)&lt;/li&gt;
  &lt;li&gt;Sharing state between components that have their own route, and thus won’t have a parent component to pass them the state through inputs or properties&lt;/li&gt;
  &lt;li&gt;Optimistic updates: Check &lt;a href=&quot;https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/&quot;&gt;this article&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Real-time updates: Check &lt;a href=&quot;https://blog.strongbrew.io/How-we-made-our-app-real-time-in-6-lines-of-code/&quot;&gt;this article&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;When we want undo/redo logic&lt;/li&gt;
  &lt;li&gt;When we want to keep track of all the state changes and debug them with awesome tooling (Redux devtools)&lt;/li&gt;
  &lt;li&gt;When we want an organised way of handling session storage or localstorage. Check &lt;a href=&quot;https://github.com/btroncone/ngrx-store-localstorage&quot;&gt;this plugin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When we are writing Angular applications it’s a best-practice to work with immutable data structures. That way we can make use of the &lt;a href=&quot;https://angular-2-training-book.rangle.io/handout/change-detection/change_detection_strategy_onpush.html&quot;&gt;OnPush changedetectionstrategy&lt;/a&gt; that angular provides us, which results in better performance and less unexpected behavior. In React we could use a &lt;a href=&quot;https://reactjs.org/docs/react-api.html#reactpurecomponent&quot;&gt;Pure component&lt;/a&gt; for that. So, for this article let’s assume that immutable datastructures are the way to go and that our application needs it.&lt;/p&gt;

&lt;p&gt;While we know that Redux forces you to use immutable datastructures, let’s still challenge the need of Redux shall we?
If statemanagement is trivial to our applications and we just want to store values we could work with a state service instead of Redux.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;@Injectable()
export class UsersService {
    private _users$ = new BehaviorSubject([]);

    get users$(): Observable&amp;lt;User[]&amp;gt; {
        return this._users$.asObservable();
    }

    // IMPORTANT: since we use an immutable dataflow
    // we have to make sure users is a new instance
    setUsers(users: User[]): void {
        this._users$.next(...users);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example shows how we can set the simple value of an array of users by calling the &lt;code&gt;setUsers()&lt;/code&gt;function. It will store the value into a BehaviorSubject which we will consume as an observable. The spread operator (&lt;code&gt;...&lt;/code&gt;) will create a new instance of the &lt;code&gt;users&lt;/code&gt; array. That way we know that we are working in an immutable manner. This was pretty easy and we don’t need Redux anymore, nor all the boilerplate that we would had to write. So if the state of our application only contains a few simple properties, the Redux pattern might be overkill.&lt;/p&gt;

&lt;p&gt;But what if we need to do more then just set the value of &lt;code&gt;users&lt;/code&gt;. What if we want to add and remove users from that stream, and we would have to do it in an immutable manner? Checkout the following example for instance.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;@Injectable()
export class UsersService {
    private _users$ = new BehaviorSubject([]);

    get users$(): Observable&amp;lt;User[]&amp;gt; {
        return this._users$.asObservable();
    }

    setUsers(users: User[]): void {
        this._users$.next(...users);
    }

    addUser(user: User): void {
        // We cannot use array.push because we only want to
        // pass immutable data to the streame
        // for the OnPush strategy remmber?
        this._users$.next([...this._users$.getValue(), user])
    }

    removeUser(id: string) {
        // Again, we have to create a new Array instance to not break the
        // immutable dataflow
        this._users$.next(this._users$.getValue().filter(v =&amp;gt; v.id !== id));
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above is starting to feel a bit weird, and it seems like we are writing reducer logic inside of this state service to keep it immutable. We have also created our own observable implementation so we could subscribe to the changes of our state service. While it could still be overkill to use redux if this is the only state in our application, it might become complex if we are working with multiple states, nested states, etc.&lt;/p&gt;

&lt;p&gt;Another example is caching. People use redux to cache data results. A simple &lt;code&gt;shareReplay&lt;/code&gt; operator might to the trick as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;fetchUsers(): Observable&amp;lt;User[]&amp;gt; {
    ...
    return this.httpClient.get('').pipe(shareReplay(1));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;I would suggest to not use Redux untill we actually need it, and in my experience most applications that I have written in the past did need redux at a certain point. That being said I also wrote a bunch of applications that didn’t need it at all (CRUD applications for instance.&lt;/p&gt;

&lt;p&gt;It’s up to you if you want to use Redux or not, &lt;strong&gt;but keep your applications immutable at all times&lt;/strong&gt;.
It will save you a lot of energy in debugging and it makes sure that you can optimise the change detection cycle in your applications.&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Apr 2018 00:00:00 +0200</pubDate>
        <link>https://blog.brecht.io/do-we-really-need-redux/</link>
        <guid isPermaLink="true">https://blog.brecht.io/do-we-really-need-redux/</guid>
        
        <category>Redux</category>
        
        
        <category>brechtbilliet</category>
        
      </item>
    
      <item>
        <title>Pre-rendering Angular Applications</title>
        <description>&lt;h2 id=&quot;why-should-we-pre-render-angular-applications&quot;&gt;Why should we pre-render Angular applications?&lt;/h2&gt;

&lt;p&gt;At the moment of writing this article, there are several ways of optimizing Angular applications - We could compile them &lt;a href=&quot;https://angular.io/guide/aot-compiler&quot;&gt;ahead-of-time&lt;/a&gt; through AOT compilation.
We could use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API&quot;&gt;service workers&lt;/a&gt; to optimize caching. And there are plenty of other PWA (progressive web app) features that can increase the quality and overall performance of our Angular applications.&lt;/p&gt;

&lt;p&gt;However, there are a still a few problems that these optimizations won’t fix:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SEO&lt;/strong&gt; (search engine optimization): At the time of writing, SPAs (single-page applications) are harder to index by search engines because the content isn’t available on load time. Therefore, the application is likely to fail on several SEO requirements.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Initial page load&lt;/strong&gt; could be faster: Since the application still needs to be bootstrapped after the page is loaded, there is an initial waiting time until the user can use the application. This results in a bad user experience.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These two problems can be fixed by implementing &lt;a href=&quot;https://angular.io/guide/universal&quot;&gt;SSR (server-side rendering)&lt;/a&gt;. SSR executes the Angular application on the server. That way the server will actually serve the compiled content in a way that search engine crawlers can read it. This is really the best of both worlds: The application will be rendered on the server, but when the JavaScript bundle is loaded, it will turn into a SPA. That way the application is rich and fast at the same time!&lt;/p&gt;

&lt;p&gt;To optimize our &lt;a href=&quot;https://strongbrew.io&quot;&gt;StrongBrew&lt;/a&gt; website, we started using this approach. It was pretty fast when we ran it locally. However, the StrongBrew website is hosted on &lt;a href=&quot;https://firebase.google.com&quot;&gt;Firebase&lt;/a&gt; and the SSR part was hosted by Firebase functions.&lt;/p&gt;

&lt;p&gt;We really love Firebase and everything it stands for, but for us, SSR on Firebase functions was just too slow. Sometimes it took 4 seconds to serve the content… Since the loading time of a website is very important for keeping our visitors, we had to find another way to serve the content in a more effective manner.&lt;/p&gt;

&lt;p&gt;SSR works like this: A user navigates to a URL =&amp;gt; the server compiles the application and serves it.
But instead of compiling every route when the server receives a request, what if we could execute the SSR logic for every route at build time? That would certainly fix our problem.&lt;/p&gt;

&lt;p&gt;That way we would run generated static HTML files, which is insanely fast, and when the JavaScript bundles are loaded, the browser would take over.
This also uses the best of both worlds: Ultra fast loading time + we don’t need to give up our rich SPA experience.
The result went from several seconds to 30 milliseconds.
&lt;img src=&quot;/assets/images/posts/prerendering-angular-apps/ssr-vs-prerender.png&quot; alt=&quot;SSR vs Prerender&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is a super fast and super effective improvement but it has one very important limitation.
&lt;strong&gt;It’s not possible to prerender dynamic content&lt;/strong&gt;. The data in the StrongBrew website isn’t fetched by AJAX calls (at least not the data that has to be indexed). It rather works with simple webpack imports of JSON files. These are inserted at build time.&lt;/p&gt;

&lt;p&gt;This does not mean that loading content dynamically isn’t possible at all, it just won’t get prerendered.&lt;/p&gt;

&lt;h2 id=&quot;lets-dive-in&quot;&gt;Let’s dive in&lt;/h2&gt;

&lt;p&gt;Enough chit chat! Let’s dive into some code.
I’ve created this &lt;a href=&quot;https://github.com/strongbrewio/prerender-angular-example&quot;&gt;GitHub repository&lt;/a&gt; just for you! It’s a simple website with a few pages and the build system doesn’t know how to pre-render yet.
Checkout the branch &lt;code&gt;runtime&lt;/code&gt; by running the command &lt;code&gt;git checkout runtime&lt;/code&gt;. When running &lt;code&gt;npm i &amp;amp;&amp;amp; npm run start&lt;/code&gt;, the bash should install all the NPM dependencies and host the application on &lt;code&gt;http://localhost:4200&lt;/code&gt;, just like any default Angular CLI application.&lt;/p&gt;

&lt;h3 id=&quot;installing-the-dependencies&quot;&gt;Installing the dependencies&lt;/h3&gt;

&lt;p&gt;Great! We have a running website, but nothing is pre-rendered yet.
The first thing we need to do is to install @angular/platform-server by running
&lt;code&gt;npm i @angular/platform-server -D&lt;/code&gt;. This is the most important bundle for SSR. This module contains the basics to run the Angular application on the server.&lt;/p&gt;

&lt;h3 id=&quot;applying-the-server-transition&quot;&gt;Applying the server transition&lt;/h3&gt;

&lt;p&gt;Next, we need to update the &lt;code&gt;app.module.ts&lt;/code&gt; to enable server transition. This will make sure that Angular takes over on the frontend when the JavaScript bundles are loaded.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// src/app/app.module.ts
@NgModule({
  ...
  imports: [
    BrowserModule.withServerTransition(
        // this is just the name of our application
        // configured in angular-cli.json
        { appId: 'prerender-angular-example' }
    ),
    ...
  ],
  ...
})
export class AppModule { }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;creating-the-prerender-module&quot;&gt;Creating the prerender module&lt;/h3&gt;

&lt;p&gt;Then, we need to create a specific prerender module that will use the AppModule we have just adjusted. Let’s create an &lt;code&gt;app.prerender.module.ts&lt;/code&gt; where we can tell which component it has to bootstrap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// src/app/app.prerender.module.ts
import { NgModule } from '@angular/core';
import { ServerModule, ServerTransferStateModule } from '@angular/platform-server';

import { AppModule } from './app.module';
import { AppComponent } from './app.component';

@NgModule({
  imports: [
    AppModule,
    ServerModule,
    ServerTransferStateModule
  ],
  bootstrap: [AppComponent]
})
export class AppPrerenderModule {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;defining-a-prerender-entrypoint&quot;&gt;Defining a prerender entrypoint&lt;/h3&gt;

&lt;p&gt;To use the SSR logic at build time, we need to have a specific bundle. Since the &lt;code&gt;main.ts&lt;/code&gt; file is used to bootstrap the application for the browser, we also need a &lt;code&gt;main.prerender.ts&lt;/code&gt; file that will be used to create the prerender bundle.
Let’s create that file, shall we?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// src/app/main.prerender.ts
import { enableProdMode } from '@angular/core';
export { AppPrerenderModule } from './app/app.prerender.module';

enableProdMode();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;a-prerender-tsconfigjson&quot;&gt;A prerender tsconfig.json&lt;/h3&gt;

&lt;p&gt;We are almost there, I promise, but we need a few more things. We need a specific &lt;strong&gt;tsconfig&lt;/strong&gt; file that compiles the bundle to something that the node server can read. It’s important for the compiler to compile to a &lt;strong&gt;commonjs&lt;/strong&gt; package. This is because node.js uses this by default. So we need to create a &lt;code&gt;tsconfig.prerender.json&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;/* src/tsconfig.prerender.json */
{
  &quot;extends&quot;: &quot;./tsconfig.app.json&quot;,
  &quot;compilerOptions&quot;: {
    &quot;outDir&quot;: &quot;../out-tsc/prerender&quot;,
    /* node only understands commonjs for now*/
    &quot;module&quot;: &quot;commonjs&quot;
  },
  &quot;exclude&quot;: [
    &quot;test.ts&quot;,
    &quot;**/*.spec.ts&quot;
  ],
  /* Additional informations to bootstrap Angular */
  &quot;angularCompilerOptions&quot;: {
    &quot;entryModule&quot;: &quot;app/app.prerender.module#AppPrerenderModule&quot;
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;letting-angular-cli-know-and-generating-the-bundle&quot;&gt;Letting Angular CLI know and generating the bundle&lt;/h3&gt;

&lt;p&gt;In the apps entry of the &lt;code&gt;angular-cli.json&lt;/code&gt; file, we need to add a new app where we refer to the &lt;code&gt;main.prerender.ts&lt;/code&gt; file and the &lt;code&gt;tsconfig.prerender.json&lt;/code&gt; file. The app section should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
      &quot;name&quot;: &quot;prerender&quot;,
      &quot;platform&quot;: &quot;server&quot;,
      &quot;root&quot;: &quot;src&quot;,
      &quot;outDir&quot;: &quot;dist-prerender&quot;,
      &quot;main&quot;: &quot;main.prerender.ts&quot;,
      &quot;tsconfig&quot;: &quot;tsconfig.prerender.json&quot;,
      &quot;environmentSource&quot;: &quot;environments/environment.ts&quot;,
      &quot;environments&quot;: {
        &quot;dev&quot;: &quot;environments/environment.ts&quot;,
        &quot;prod&quot;: &quot;environments/environment.prod.ts&quot;
      }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update the package JSON so it builds both the normal package and the server package. Set the &lt;strong&gt;output-hashing&lt;/strong&gt; to none so that the build generates a clean &lt;code&gt;main.bundle.js&lt;/code&gt; without any hash.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &quot;build&quot;: &quot;ng build --prod &amp;amp;&amp;amp; ng build --prod --app prerender --output-hashing=none&quot;,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When running &lt;code&gt;npm run build&lt;/code&gt; the following files should be created:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;dist (this contains the normal build)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;dist-prerender/main.bundle.js&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This &lt;code&gt;main.bundle.js&lt;/code&gt; file exports a module called &lt;code&gt;AppPrerenderModuleNgFactory&lt;/code&gt;. This is the module that we can use to pre-render the whole thing.&lt;/p&gt;

&lt;h2 id=&quot;generating-the-static-files&quot;&gt;Generating the static files&lt;/h2&gt;

&lt;p&gt;We have just generated the &lt;code&gt;main.bundle.js&lt;/code&gt;, the file that we need to perform server-side rendering. However we don’t want to do server-side rendering in this case, we want to &lt;strong&gt;pre-render&lt;/strong&gt; the html at build time. To do that we need a script that will complete the following steps.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Create an array with routes (we could automate this if we want)&lt;/li&gt;
  &lt;li&gt;Loop over that array and for every entry:
    &lt;ul&gt;
      &lt;li&gt;create a folder in the dist map with that route name&lt;/li&gt;
      &lt;li&gt;use the &lt;code&gt;main.bundle.js&lt;/code&gt; to render the html and store that html as an &lt;code&gt;index.html&lt;/code&gt; in the folder we just created.&lt;/li&gt;
      &lt;li&gt;Overwrite the &lt;code&gt;dist/index.html&lt;/code&gt; file.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s call that script &lt;code&gt;prerender.ts&lt;/code&gt;. Since I’m a typescript enthusiast, I want to develop the prerender script in typescript and use &lt;a href=&quot;https://www.npmjs.com/package/ts-node&quot;&gt;ts-node&lt;/a&gt; to run it.
We can start with creating an empty &lt;code&gt;prerender.ts&lt;/code&gt; file in the root folder and installing ts-node with &lt;code&gt;npm i -D ts-node&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now we can update the scripts section of the package.json so that the render function is called when the build is completed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt; &quot;scripts&quot;: {
    &quot;ng&quot;: &quot;ng&quot;,
    &quot;start&quot;: &quot;ng serve&quot;,
    &quot;build&quot;: &quot;ng build --prod &amp;amp;&amp;amp; ng build --prod --app prerender --output-hashing=none&quot;,
    &quot;postbuild&quot;: &quot;npm run render&quot;,
    &quot;render&quot;: &quot;ts-node prerender.ts&quot;,
    ...
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only puzzle piece that is still missing is implementing the &lt;code&gt;prerender.ts&lt;/code&gt; file.&lt;/p&gt;

&lt;h3 id=&quot;completing-the-prerenderts-file&quot;&gt;Completing the prerender.ts file&lt;/h3&gt;

&lt;p&gt;The following code should be self-explanatory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;import 'zone.js/dist/zone-node';
import * as path from 'path';
import * as fs from 'fs';
import { enableProdMode } from '@angular/core';
import { renderModuleFactory } from '@angular/platform-server';
import { AppPrerenderModuleNgFactory } from './dist-prerender/main.bundle';

const distFolder = './dist';
const index = fs
    .readFileSync(path.resolve(__dirname, `${distFolder}/index.html`), 'utf8')
    .toString();

// we could automate this based on the app.routes.ts file but
// to keep it simple let's just create an array with the routes we want
// to prerender
const paths = [
    '/about',
    '/brews',
    '/consultancy'];
enableProdMode();

// for every route render the html and save it in the correct folder
paths.forEach(p =&amp;gt; renderToHtml(p, distFolder + p));

// don't forget to overwrite the index.html as well
renderToHtml('/index.html', distFolder);

function renderToHtml(url: string, folderPath: string): void {
  // Render the module with the correct url just 
  // as the server would do
  renderModuleFactory(AppPrerenderModuleNgFactory, {
    url,
    document: index
  }).then(html =&amp;gt; {
    // create the route directory
    if (url !== '/index.html') {
    fs.mkdirSync(folderPath);
    }
    fs.writeFile(folderPath + '/index.html', html,  (err =&amp;gt;  {
      if (err) {
        throw err;
      }
      console.log(`success`);
    });
  });
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;testing-the-pre-rendered-application&quot;&gt;Testing the pre-rendered application&lt;/h3&gt;

&lt;p&gt;To test the website, we can build the project with &lt;code&gt;npm run build&lt;/code&gt;. To serve it, we can use http-server. We can install http-server by running &lt;code&gt;npm i -g http-server&lt;/code&gt;. By navigating into the &lt;code&gt;dist&lt;/code&gt; directory and running &lt;code&gt;http-server&lt;/code&gt;, the application will be hosted on port 8080.&lt;/p&gt;

&lt;p&gt;If we navigate to http://localhost:8080 in the browser, we will see the pre-rendered application. We can test the SPA experience by navigating between the different pages and we can test the pre-rendered part by looking at the source code.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/prerendering-angular-apps/sourcecode.png&quot; alt=&quot;SSR sourcecode&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;closing-words&quot;&gt;Closing words&lt;/h2&gt;

&lt;p&gt;I hope you liked this article and learned something.
We can find the full pre-rendered version by checking out branch &lt;code&gt;prerendered&lt;/code&gt; by running &lt;code&gt;git checkout prerendered&lt;/code&gt;. To test this example, checkout the previous section.&lt;/p&gt;

&lt;p&gt;Note: to optimize the HTML even more, we could use an HTML minifier like &lt;a href=&quot;https://www.npmjs.com/package/html-minifier&quot;&gt;this one&lt;/a&gt; to shrink the HTML where possible. The example could look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const minify = require('html-minifier').minify;
function renderToHtml(url: string, folderPath: string): void {
    // Render the module with the correct url just 
    // as the server would do
    renderModuleFactory(AppPrerenderModuleNgFactory, {
        url,
        document: index
    }).then(html =&amp;gt; {
        ...
        // minify the html
        fs.writeFile(folderPath + '/index.html', minify(html),  (err =&amp;gt;  {
          ...
        });
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;special-thanks&quot;&gt;Special thanks&lt;/h2&gt;

&lt;p&gt;A very special thanks to the awesome people that have helped me with their reviews:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Laurant Duveau &lt;a href=&quot;https://twitter.com/laurentduveau&quot;&gt;@laurentduveau&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Dominic Elm &lt;a href=&quot;https://twitter.com/elmd_&quot;&gt;@elmd_&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Sam Vloeberghs &lt;a href=&quot;https://twitter.com/samvloeberghs&quot;&gt;@samvloeberghs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Ana Cidre &lt;a href=&quot;https://twitter.com/anacidre_&quot;&gt;@AnaCidre_&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Ruben Vermeulen &lt;a href=&quot;https://twitter.com/CrushTheButton&quot;&gt;@CrushTheButton&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Klaas Cuvelier &lt;a href=&quot;https://twitter.com/klaascuvelier&quot;&gt;@klaascuvelier&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sources&quot;&gt;Sources&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://hackernoon.com/deploy-angular-universal-w-firebase-ad70ea2413a1&quot;&gt;deploy angular universal with firebase&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 00:00:00 +0100</pubDate>
        <link>https://blog.brecht.io/prerendering-angular-apps/</link>
        <guid isPermaLink="true">https://blog.brecht.io/prerendering-angular-apps/</guid>
        
        <category>Angular</category>
        
        
        <category>brechtbilliet</category>
        
      </item>
    
  </channel>
</rss>
